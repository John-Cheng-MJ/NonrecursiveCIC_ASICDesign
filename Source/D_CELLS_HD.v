//************************************************************************************
// Copyright        : (c) All Rights Reserved
// Company          : X-FAB Semiconductor Foundries AG
// Address          : Haarbergstr. 67,  D-99097 Erfurt, Germany
//
// File             : D_CELLS_HD.v
// Description      : Verilog model file for Library D_CELLS_HD
//                  : with negative timing check support; 
//                  : xt018, Digital Logic Library, 
//                  : 1.8V, 1.2V Standard Speed & Low Power,
//                  : High Density routing pitch
//
// Technology       : 0.18um HV SOI CMOS
// Lib_version      : 4.0.0, Tue Dec  5 07:10:53 2017
// Created by       : X-FAB Library Characterizer XLICDD 
// Program version  : XLICDD - waz2_gvt_main, 2.1000 build 131 Time stamp:
//                    Mon Dec  4 10:01:18 2017
// Last Modified by : XLICDD generated
//
// #######################################################################
//
//  Copyright (c) X-FAB Semiconductor Foundries AG . All rights reserved.
//  This Design Kit data and the associated documentation are
//  confidential and proprietary to X-FAB Semiconductor Foundries AG.
//
//  DISCLAIMER
//  The information contained herein is provided by X-FAB Semiconductor
//  Foundries AG  on an "AS IS" basis without any warranty.
//
//  X-FAB Semiconductor Foundries AG disclaims any representation that
//  the information does not infringe any intellectual property rights or 
//  proprietary rights of any third parties. There are no other warranties 
//  given by X-FAB, whether express, implied or statutory, including, 
//  without limitation, implied warranties of merchantability and fitness 
//  for a particular purpose.
//
//  In no event X-FAB Semiconductor Foundries AG will be liable or 
//  responsible for any expense, losses, damages, or action incurred or 
//  undertaken as a result of the receipt of the information.
// 
//  X-FAB Semiconductor Foundries AG  reserves the right to make changes
//  to the information at any time and without notice.
//
// #######################################################################
// ***********************************************************************
// Remark:
// 
// This Verilog library uses  User Defined Primitives (UDP)
// which are defined in the Verilog library file VLG_PRIMITIVES.v.
//
// If an ATPG tool is used then the compiler directive 
//   `define ATPG_RUN yes
// has to be set before reading this library.
// 
// Use the compiler directive command
//   `define  DISPLAY_HOLD yes
// to enable the logic pullup/down behaviour of the Leakage current 
// compensator cell SIGNALHOLD* (see also the comment in the SIGNALHOLD* 
// cell model)
// 
// Use the compiler directive command
//   `define  NEG_TCHK yes
// to enable the syntax support for negative timing checks. 
//
//************************************************************************/
 

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN211HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input AND into 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN211HDX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A*B)+C+D)
   and       i0  (n_0, A, B);
   nor       i1  (Q, n_0, C, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN211HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input AND into 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN211HDX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A*B)+C+D)
   and       i0  (n_0, A, B);
   nor       i1  (Q, n_0, C, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN211HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input AND into 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN211HDX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A*B)+C+D)
   and       i0  (n_0, A, B);
   nor       i1  (Q, n_0, C, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN211HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input AND into 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN211HDX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A*B)+C+D)
   and       i0  (n_0, A, B);
   nor       i1  (Q, n_0, C, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN21HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input AND into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN21HDX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !((A*B)+C)
   and       i0  (n_0, A, B);
   nor       i1  (Q, n_0, C);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN21HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input AND into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN21HDX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !((A*B)+C)
   and       i0  (n_0, A, B);
   nor       i1  (Q, n_0, C);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN21HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input AND into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN21HDX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !((A*B)+C)
   and       i0  (n_0, A, B);
   nor       i1  (Q, n_0, C);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN21HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input AND into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN21HDX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !((A*B)+C)
   and       i0  (n_0, A, B);
   nor       i1  (Q, n_0, C);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN221HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input AND into 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN221HDX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A*B)+(C*D)+E)
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   nor       i2  (Q, n_0, n_1, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D ==
                   1'b1)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN221HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input AND into 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN221HDX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A*B)+(C*D)+E)
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   nor       i2  (Q, n_0, n_1, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D ==
                   1'b1)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN221HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input AND into 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN221HDX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A*B)+(C*D)+E)
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   nor       i2  (Q, n_0, n_1, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D ==
                   1'b1)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN221HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input AND into 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN221HDX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A*B)+(C*D)+E)
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   nor       i2  (Q, n_0, n_1, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D ==
                   1'b1)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN222HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3x2-Input AND into 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN222HDX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A*B)+(C*D)+(E*F))
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   and       i2  (n_2, E, F);
   nor       i3  (Q, n_0, n_1, n_2);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C -=> Q) =
                   (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D -=> Q) =
                   (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1
                   && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) =
                   (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1
                   && D == 1'b0)) (F -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0)) (F -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F -=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN222HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3x2-Input AND into 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN222HDX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A*B)+(C*D)+(E*F))
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   and       i2  (n_2, E, F);
   nor       i3  (Q, n_0, n_1, n_2);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C -=> Q) =
                   (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D -=> Q) =
                   (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1
                   && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) =
                   (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1
                   && D == 1'b0)) (F -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0)) (F -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F -=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN222HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3x2-Input AND into 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN222HDX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A*B)+(C*D)+(E*F))
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   and       i2  (n_2, E, F);
   nor       i3  (Q, n_0, n_1, n_2);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C -=> Q) =
                   (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D -=> Q) =
                   (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1
                   && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) =
                   (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1
                   && D == 1'b0)) (F -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0)) (F -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F -=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN222HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3x2-Input AND into 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN222HDX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A*B)+(C*D)+(E*F))
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   and       i2  (n_2, E, F);
   nor       i3  (Q, n_0, n_1, n_2);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C -=> Q) =
                   (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D -=> Q) =
                   (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1
                   && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) =
                   (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1
                   && D == 1'b0)) (F -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0)) (F -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F -=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN22HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input AND into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN22HDX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A*B)+(C*D))
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   nor       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN22HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input AND into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN22HDX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A*B)+(C*D))
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   nor       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN22HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input AND into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN22HDX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A*B)+(C*D))
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   nor       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN22HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input AND into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN22HDX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A*B)+(C*D))
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   nor       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN311HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND into 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN311HDX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A*B*C)+D+E)
   and       i0  (n_0, A, B, C);
   nor       i1  (Q, n_0, D, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN311HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND into 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN311HDX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A*B*C)+D+E)
   and       i0  (n_0, A, B, C);
   nor       i1  (Q, n_0, D, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN311HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND into 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN311HDX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A*B*C)+D+E)
   and       i0  (n_0, A, B, C);
   nor       i1  (Q, n_0, D, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN311HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND into 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN311HDX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A*B*C)+D+E)
   and       i0  (n_0, A, B, C);
   nor       i1  (Q, n_0, D, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN31HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN31HDX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A*B*C)+D)
   and       i0  (n_0, A, B, C);
   nor       i1  (Q, n_0, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN31HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN31HDX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A*B*C)+D)
   and       i0  (n_0, A, B, C);
   nor       i1  (Q, n_0, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN31HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN31HDX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A*B*C)+D)
   and       i0  (n_0, A, B, C);
   nor       i1  (Q, n_0, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN31HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN31HDX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A*B*C)+D)
   and       i0  (n_0, A, B, C);
   nor       i1  (Q, n_0, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN321HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND, 2-Input AND into 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN321HDX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A*B*C)+(D*E)+F)
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E);
   nor       i2  (Q, n_0, n_1, F);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0
                   && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1
                   && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0
                   && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1
                   && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1
                   && E == 1'b0) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D
                   == 1'b0 && E == 1'b0) || (A == 1'b0 && B == 1'b1 && C ==
                   1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0)
                   || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E
                   == 1'b1)) (F -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1))
                   (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN321HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND, 2-Input AND into 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN321HDX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A*B*C)+(D*E)+F)
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E);
   nor       i2  (Q, n_0, n_1, F);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0
                   && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1
                   && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0
                   && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1
                   && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1
                   && E == 1'b0) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D
                   == 1'b0 && E == 1'b0) || (A == 1'b0 && B == 1'b1 && C ==
                   1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0)
                   || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E
                   == 1'b1)) (F -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1))
                   (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN321HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND, 2-Input AND into 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN321HDX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A*B*C)+(D*E)+F)
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E);
   nor       i2  (Q, n_0, n_1, F);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0
                   && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1
                   && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0
                   && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1
                   && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1
                   && E == 1'b0) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D
                   == 1'b0 && E == 1'b0) || (A == 1'b0 && B == 1'b1 && C ==
                   1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0)
                   || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E
                   == 1'b1)) (F -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1))
                   (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN321HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND, 2-Input AND into 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN321HDX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A*B*C)+(D*E)+F)
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E);
   nor       i2  (Q, n_0, n_1, F);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0
                   && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1
                   && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0
                   && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1
                   && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1
                   && E == 1'b0) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D
                   == 1'b0 && E == 1'b0) || (A == 1'b0 && B == 1'b1 && C ==
                   1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0)
                   || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E
                   == 1'b1)) (F -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1))
                   (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN32HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input, 2-Input AND into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN32HDX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A*B*C)+(D*E))
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E);
   nor       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1
                   && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0
                   && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN32HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input, 2-Input AND into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN32HDX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A*B*C)+(D*E))
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E);
   nor       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1
                   && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0
                   && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN32HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input, 2-Input AND into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN32HDX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A*B*C)+(D*E))
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E);
   nor       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1
                   && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0
                   && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN32HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input, 2-Input AND into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN32HDX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A*B*C)+(D*E))
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E);
   nor       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1
                   && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0
                   && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN33HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x3-Input AND into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN33HDX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A*B*C)+(D*E*F))
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E, F);
   nor       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN33HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x3-Input AND into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN33HDX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A*B*C)+(D*E*F))
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E, F);
   nor       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN33HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x3-Input AND into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN33HDX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A*B*C)+(D*E*F))
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E, F);
   nor       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AN33HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x3-Input AND into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module AN33HDX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A*B*C)+(D*E*F))
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E, F);
   nor       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AND2HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module AND2HDX0 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: (A*B)
   and       i0  (Q, A, B);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AND2HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module AND2HDX1 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: (A*B)
   and       i0  (Q, A, B);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AND2HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module AND2HDX2 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: (A*B)
   and       i0  (Q, A, B);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AND2HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module AND2HDX4 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: (A*B)
   and       i0  (Q, A, B);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AND3HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module AND3HDX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: (A*B*C)
   and       i0  (Q, A, B, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AND3HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module AND3HDX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: (A*B*C)
   and       i0  (Q, A, B, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AND3HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module AND3HDX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: (A*B*C)
   and       i0  (Q, A, B, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AND3HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module AND3HDX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: (A*B*C)
   and       i0  (Q, A, B, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AND4HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module AND4HDX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: (A*B*C*D)
   and       i0  (Q, A, B, C, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AND4HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module AND4HDX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: (A*B*C*D)
   and       i0  (Q, A, B, C, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AND4HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module AND4HDX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: (A*B*C*D)
   and       i0  (Q, A, B, C, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AND4HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module AND4HDX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: (A*B*C*D)
   and       i0  (Q, A, B, C, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AND5HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module AND5HDX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: (A*B*C*D*E)
   and       i0  (Q, A, B, C, D, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AND5HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module AND5HDX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: (A*B*C*D*E)
   and       i0  (Q, A, B, C, D, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AND5HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module AND5HDX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: (A*B*C*D*E)
   and       i0  (Q, A, B, C, D, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AND5HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module AND5HDX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: (A*B*C*D*E)
   and       i0  (Q, A, B, C, D, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AND6HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module AND6HDX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: (A*B*C*D*E*F)
   and       i0  (Q, A, B, C, D, E, F);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AND6HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module AND6HDX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: (A*B*C*D*E*F)
   and       i0  (Q, A, B, C, D, E, F);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AND6HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module AND6HDX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: (A*B*C*D*E*F)
   and       i0  (Q, A, B, C, D, E, F);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AND6HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module AND6HDX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: (A*B*C*D*E*F)
   and       i0  (Q, A, B, C, D, E, F);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO211HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input AND into 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO211HDX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A*B)+C+D)
   and       i0  (n_0, A, B);
   or        i1  (Q, n_0, C, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO211HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input AND into 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO211HDX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A*B)+C+D)
   and       i0  (n_0, A, B);
   or        i1  (Q, n_0, C, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO211HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input AND into 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO211HDX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A*B)+C+D)
   and       i0  (n_0, A, B);
   or        i1  (Q, n_0, C, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO211HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input AND into 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO211HDX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A*B)+C+D)
   and       i0  (n_0, A, B);
   or        i1  (Q, n_0, C, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO21HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input AND into 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO21HDX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: ((A*B)+C)
   and       i0  (n_0, A, B);
   or        i1  (Q, n_0, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO21HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input AND into 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO21HDX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: ((A*B)+C)
   and       i0  (n_0, A, B);
   or        i1  (Q, n_0, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO21HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input AND into 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO21HDX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: ((A*B)+C)
   and       i0  (n_0, A, B);
   or        i1  (Q, n_0, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO21HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input AND into 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO21HDX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: ((A*B)+C)
   and       i0  (n_0, A, B);
   or        i1  (Q, n_0, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO221HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input AND into 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO221HDX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A*B)+(C*D)+E)
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   or        i2  (Q, n_0, n_1, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D ==
                   1'b1)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO221HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input AND into 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO221HDX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A*B)+(C*D)+E)
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   or        i2  (Q, n_0, n_1, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D ==
                   1'b1)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO221HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input AND into 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO221HDX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A*B)+(C*D)+E)
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   or        i2  (Q, n_0, n_1, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D ==
                   1'b1)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO221HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input AND into 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO221HDX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A*B)+(C*D)+E)
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   or        i2  (Q, n_0, n_1, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D ==
                   1'b1)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO222HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3x2-Input AND into 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO222HDX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A*B)+(C*D)+(E*F))
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   and       i2  (n_2, E, F);
   or        i3  (Q, n_0, n_1, n_2);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C +=> Q) =
                   (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D +=> Q) =
                   (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1
                   && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) =
                   (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1
                   && D == 1'b0)) (F +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0)) (F +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F +=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO222HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3x2-Input AND into 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO222HDX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A*B)+(C*D)+(E*F))
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   and       i2  (n_2, E, F);
   or        i3  (Q, n_0, n_1, n_2);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C +=> Q) =
                   (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D +=> Q) =
                   (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1
                   && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) =
                   (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1
                   && D == 1'b0)) (F +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0)) (F +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F +=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO222HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3x2-Input AND into 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO222HDX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A*B)+(C*D)+(E*F))
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   and       i2  (n_2, E, F);
   or        i3  (Q, n_0, n_1, n_2);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C +=> Q) =
                   (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D +=> Q) =
                   (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1
                   && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) =
                   (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1
                   && D == 1'b0)) (F +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0)) (F +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F +=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO222HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3x2-Input AND into 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO222HDX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A*B)+(C*D)+(E*F))
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   and       i2  (n_2, E, F);
   or        i3  (Q, n_0, n_1, n_2);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C +=> Q) =
                   (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D +=> Q) =
                   (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1
                   && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) =
                   (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1
                   && D == 1'b0)) (F +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && D == 1'b0)) (F +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F +=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO22HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input AND into 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO22HDX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A*B)+(C*D))
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   or        i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO22HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input AND into 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO22HDX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A*B)+(C*D))
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   or        i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO22HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input AND into 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO22HDX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A*B)+(C*D))
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   or        i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO22HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input AND into 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO22HDX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A*B)+(C*D))
   and       i0  (n_0, A, B);
   and       i1  (n_1, C, D);
   or        i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO311HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND into 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO311HDX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A*B*C)+D+E)
   and       i0  (n_0, A, B, C);
   or        i1  (Q, n_0, D, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO311HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND into 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO311HDX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A*B*C)+D+E)
   and       i0  (n_0, A, B, C);
   or        i1  (Q, n_0, D, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO311HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND into 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO311HDX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A*B*C)+D+E)
   and       i0  (n_0, A, B, C);
   or        i1  (Q, n_0, D, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO311HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND into 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO311HDX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A*B*C)+D+E)
   and       i0  (n_0, A, B, C);
   or        i1  (Q, n_0, D, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO31HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND into 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO31HDX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A*B*C)+D)
   and       i0  (n_0, A, B, C);
   or        i1  (Q, n_0, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO31HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND into 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO31HDX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A*B*C)+D)
   and       i0  (n_0, A, B, C);
   or        i1  (Q, n_0, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO31HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND into 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO31HDX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A*B*C)+D)
   and       i0  (n_0, A, B, C);
   or        i1  (Q, n_0, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO31HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND into 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO31HDX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A*B*C)+D)
   and       i0  (n_0, A, B, C);
   or        i1  (Q, n_0, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO321HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND, 2-Input AND into 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO321HDX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A*B*C)+(D*E)+F)
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E);
   or        i2  (Q, n_0, n_1, F);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0
                   && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1
                   && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0
                   && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1
                   && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1
                   && E == 1'b0) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D
                   == 1'b0 && E == 1'b0) || (A == 1'b0 && B == 1'b1 && C ==
                   1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0)
                   || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E
                   == 1'b1)) (F +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1))
                   (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO321HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND, 2-Input AND into 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO321HDX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A*B*C)+(D*E)+F)
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E);
   or        i2  (Q, n_0, n_1, F);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0
                   && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1
                   && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0
                   && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1
                   && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1
                   && E == 1'b0) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D
                   == 1'b0 && E == 1'b0) || (A == 1'b0 && B == 1'b1 && C ==
                   1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0)
                   || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E
                   == 1'b1)) (F +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1))
                   (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO321HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND, 2-Input AND into 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO321HDX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A*B*C)+(D*E)+F)
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E);
   or        i2  (Q, n_0, n_1, F);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0
                   && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1
                   && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0
                   && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1
                   && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1
                   && E == 1'b0) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D
                   == 1'b0 && E == 1'b0) || (A == 1'b0 && B == 1'b1 && C ==
                   1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0)
                   || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E
                   == 1'b1)) (F +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1))
                   (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO321HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input AND, 2-Input AND into 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO321HDX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A*B*C)+(D*E)+F)
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E);
   or        i2  (Q, n_0, n_1, F);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0))
                   (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0
                   && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1
                   && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0
                   && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1
                   && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1
                   && E == 1'b0) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D
                   == 1'b0 && E == 1'b0) || (A == 1'b0 && B == 1'b1 && C ==
                   1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0)
                   || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E
                   == 1'b1)) (F +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1))
                   (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO32HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input, 2-Input AND into 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO32HDX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A*B*C)+(D*E))
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E);
   or        i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1
                   && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0
                   && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO32HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input, 2-Input AND into 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO32HDX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A*B*C)+(D*E))
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E);
   or        i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1
                   && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0
                   && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO32HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input, 2-Input AND into 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO32HDX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A*B*C)+(D*E))
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E);
   or        i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1
                   && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0
                   && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO32HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input, 2-Input AND into 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO32HDX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A*B*C)+(D*E))
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E);
   or        i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((E == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1
                   && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0
                   && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO33HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x3-Input AND into 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO33HDX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A*B*C)+(D*E*F))
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E, F);
   or        i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO33HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x3-Input AND into 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO33HDX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A*B*C)+(D*E*F))
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E, F);
   or        i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO33HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x3-Input AND into 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO33HDX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A*B*C)+(D*E*F))
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E, F);
   or        i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : AO33HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x3-Input AND into 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module AO33HDX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A*B*C)+(D*E*F))
   and       i0  (n_0, A, B, C);
   and       i1  (n_1, D, E, F);
   or        i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1))
                   (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((C == 1'b1)) (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : BTHHDX12
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Buffer with active high Enable
//   last modified by : XLICDD generated
//****************************************************************************

module BTHHDX12 (A, E, Q);

   input     A, E;
   output    Q;

// Function Q: A; Tristate function: !E
   bufif1    i1  (Q, A, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (E  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : BTHHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Buffer with active high Enable
//   last modified by : XLICDD generated
//****************************************************************************

module BTHHDX1 (A, E, Q);

   input     A, E;
   output    Q;

// Function Q: A; Tristate function: !E
   bufif1    i1  (Q, A, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (E  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : BTHHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Buffer with active high Enable
//   last modified by : XLICDD generated
//****************************************************************************

module BTHHDX2 (A, E, Q);

   input     A, E;
   output    Q;

// Function Q: A; Tristate function: !E
   bufif1    i1  (Q, A, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (E  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : BTHHDX3
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Buffer with active high Enable
//   last modified by : XLICDD generated
//****************************************************************************

module BTHHDX3 (A, E, Q);

   input     A, E;
   output    Q;

// Function Q: A; Tristate function: !E
   bufif1    i1  (Q, A, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (E  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : BTHHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Buffer with active high Enable
//   last modified by : XLICDD generated
//****************************************************************************

module BTHHDX4 (A, E, Q);

   input     A, E;
   output    Q;

// Function Q: A; Tristate function: !E
   bufif1    i1  (Q, A, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (E  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : BTHHDX6
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Buffer with active high Enable
//   last modified by : XLICDD generated
//****************************************************************************

module BTHHDX6 (A, E, Q);

   input     A, E;
   output    Q;

// Function Q: A; Tristate function: !E
   bufif1    i1  (Q, A, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (E  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : BTHHDX8
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Buffer with active high Enable
//   last modified by : XLICDD generated
//****************************************************************************

module BTHHDX8 (A, E, Q);

   input     A, E;
   output    Q;

// Function Q: A; Tristate function: !E
   bufif1    i1  (Q, A, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (E  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : BTLHDX12
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Buffer with active low Enable
//   last modified by : XLICDD generated
//****************************************************************************

module BTLHDX12 (A, EN, Q);

   input     A, EN;
   output    Q;

// Function Q: A; Tristate function: EN
   bufif0    i0  (Q, A, EN);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : BTLHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Buffer with active low Enable
//   last modified by : XLICDD generated
//****************************************************************************

module BTLHDX1 (A, EN, Q);

   input     A, EN;
   output    Q;

// Function Q: A; Tristate function: EN
   bufif0    i0  (Q, A, EN);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : BTLHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Buffer with active low Enable
//   last modified by : XLICDD generated
//****************************************************************************

module BTLHDX2 (A, EN, Q);

   input     A, EN;
   output    Q;

// Function Q: A; Tristate function: EN
   bufif0    i0  (Q, A, EN);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : BTLHDX3
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Buffer with active low Enable
//   last modified by : XLICDD generated
//****************************************************************************

module BTLHDX3 (A, EN, Q);

   input     A, EN;
   output    Q;

// Function Q: A; Tristate function: EN
   bufif0    i0  (Q, A, EN);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : BTLHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Buffer with active low Enable
//   last modified by : XLICDD generated
//****************************************************************************

module BTLHDX4 (A, EN, Q);

   input     A, EN;
   output    Q;

// Function Q: A; Tristate function: EN
   bufif0    i0  (Q, A, EN);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : BTLHDX6
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Buffer with active low Enable
//   last modified by : XLICDD generated
//****************************************************************************

module BTLHDX6 (A, EN, Q);

   input     A, EN;
   output    Q;

// Function Q: A; Tristate function: EN
   bufif0    i0  (Q, A, EN);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : BTLHDX8
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Buffer with active low Enable
//   last modified by : XLICDD generated
//****************************************************************************

module BTLHDX8 (A, EN, Q);

   input     A, EN;
   output    Q;

// Function Q: A; Tristate function: EN
   bufif0    i0  (Q, A, EN);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : BUHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Buffer
//   last modified by : XLICDD generated
//****************************************************************************

module BUHDX0 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : BUHDX12
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Buffer
//   last modified by : XLICDD generated
//****************************************************************************

module BUHDX12 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : BUHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Buffer
//   last modified by : XLICDD generated
//****************************************************************************

module BUHDX1 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : BUHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Buffer
//   last modified by : XLICDD generated
//****************************************************************************

module BUHDX2 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : BUHDX3
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Buffer
//   last modified by : XLICDD generated
//****************************************************************************

module BUHDX3 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : BUHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Buffer
//   last modified by : XLICDD generated
//****************************************************************************

module BUHDX4 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : BUHDX6
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Buffer
//   last modified by : XLICDD generated
//****************************************************************************

module BUHDX6 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : BUHDX8
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Buffer
//   last modified by : XLICDD generated
//****************************************************************************

module BUHDX8 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : CAGHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Carry Generator
//   last modified by : XLICDD generated
//****************************************************************************

module CAGHDX0 (A, B, CI, CO);

   input     A, B, CI;
   output    CO;

// Function CO: (B*CI) + (A*CI) + (A*B)
   and       i0  (n_0, B, CI);
   and       i1  (n_1, A, CI);
   and       i2  (n_2, A, B);
   or        i3  (CO, n_0, n_1, n_2);

// timing section:
   specify

      (A +=> CO) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : CAGHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Carry Generator
//   last modified by : XLICDD generated
//****************************************************************************

module CAGHDX1 (A, B, CI, CO);

   input     A, B, CI;
   output    CO;

// Function CO: (B*CI) + (A*CI) + (A*B)
   and       i0  (n_0, B, CI);
   and       i1  (n_1, A, CI);
   and       i2  (n_2, A, B);
   or        i3  (CO, n_0, n_1, n_2);

// timing section:
   specify

      (A +=> CO) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : CAGHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Carry Generator
//   last modified by : XLICDD generated
//****************************************************************************

module CAGHDX2 (A, B, CI, CO);

   input     A, B, CI;
   output    CO;

// Function CO: (B*CI) + (A*CI) + (A*B)
   and       i0  (n_0, B, CI);
   and       i1  (n_1, A, CI);
   and       i2  (n_2, A, B);
   or        i3  (CO, n_0, n_1, n_2);

// timing section:
   specify

      (A +=> CO) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : CAGHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Carry Generator
//   last modified by : XLICDD generated
//****************************************************************************

module CAGHDX4 (A, B, CI, CO);

   input     A, B, CI;
   output    CO;

// Function CO: (B*CI) + (A*CI) + (A*B)
   and       i0  (n_0, B, CI);
   and       i1  (n_1, A, CI);
   and       i2  (n_2, A, B);
   or        i3  (CO, n_0, n_1, n_2);

// timing section:
   specify

      (A +=> CO) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop
//   last modified by : XLICDD generated
//****************************************************************************

module DFFHDX0 (CN, D, Q, QN);

   input     CN, D;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, d_clock_i, IQN;

   not       i0  (d_clock_i, delay_CN);
   u1_fd5    i1  (IQ, delay_D, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);


// timing section:
   specify

      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_D);
      $setuphold (negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_D);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN;

   not       i0  (clock_i, CN);
   u1_fd5    i1  (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);


// timing section:
   specify

      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop
//   last modified by : XLICDD generated
//****************************************************************************

module DFFHDX1 (CN, D, Q, QN);

   input     CN, D;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, d_clock_i, IQN;

   not       i0  (d_clock_i, delay_CN);
   u1_fd5    i1  (IQ, delay_D, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);


// timing section:
   specify

      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_D);
      $setuphold (negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_D);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN;

   not       i0  (clock_i, CN);
   u1_fd5    i1  (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);


// timing section:
   specify

      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop
//   last modified by : XLICDD generated
//****************************************************************************

module DFFHDX2 (CN, D, Q, QN);

   input     CN, D;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, d_clock_i, IQN;

   not       i0  (d_clock_i, delay_CN);
   u1_fd5    i1  (IQ, delay_D, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);


// timing section:
   specify

      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_D);
      $setuphold (negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_D);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN;

   not       i0  (clock_i, CN);
   u1_fd5    i1  (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);


// timing section:
   specify

      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop
//   last modified by : XLICDD generated
//****************************************************************************

module DFFHDX4 (CN, D, Q, QN);

   input     CN, D;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, d_clock_i, IQN;

   not       i0  (d_clock_i, delay_CN);
   u1_fd5    i1  (IQ, delay_D, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);


// timing section:
   specify

      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_D);
      $setuphold (negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_D);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN;

   not       i0  (clock_i, CN);
   u1_fd5    i1  (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);


// timing section:
   specify

      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop
//   last modified by : XLICDD generated
//****************************************************************************

module DFFQHDX0 (CN, D, Q);

   input     CN, D;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, d_clock_i;

   not       i0  (d_clock_i, delay_CN);
   u1_fd5    i1  (IQ, delay_D, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);


// timing section:
   specify

      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_D);
      $setuphold (negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_D);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i;

   not       i0  (clock_i, CN);
   u1_fd5    i1  (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);


// timing section:
   specify

      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop
//   last modified by : XLICDD generated
//****************************************************************************

module DFFQHDX1 (CN, D, Q);

   input     CN, D;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, d_clock_i;

   not       i0  (d_clock_i, delay_CN);
   u1_fd5    i1  (IQ, delay_D, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);


// timing section:
   specify

      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_D);
      $setuphold (negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_D);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i;

   not       i0  (clock_i, CN);
   u1_fd5    i1  (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);


// timing section:
   specify

      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop
//   last modified by : XLICDD generated
//****************************************************************************

module DFFQHDX2 (CN, D, Q);

   input     CN, D;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, d_clock_i;

   not       i0  (d_clock_i, delay_CN);
   u1_fd5    i1  (IQ, delay_D, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);


// timing section:
   specify

      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_D);
      $setuphold (negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_D);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i;

   not       i0  (clock_i, CN);
   u1_fd5    i1  (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);


// timing section:
   specify

      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop
//   last modified by : XLICDD generated
//****************************************************************************

module DFFQHDX4 (CN, D, Q);

   input     CN, D;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, d_clock_i;

   not       i0  (d_clock_i, delay_CN);
   u1_fd5    i1  (IQ, delay_D, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);


// timing section:
   specify

      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_D);
      $setuphold (negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_D);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i;

   not       i0  (clock_i, CN);
   u1_fd5    i1  (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);


// timing section:
   specify

      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFRHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Reset
//   last modified by : XLICDD generated
//****************************************************************************

module DFFRHDX0 (CN, D, Q, QN, RN);

   input     CN, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_RN, d_clock_i, IQN, c_SH_D;

   not       i1  (d_clock_i, delay_CN);
   u1_fd5    i2  (IQ, delay_D, d_clock_i, delay_RN, 1'b1, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, c_SH_D;

   not       i1  (clock_i, CN);
   u1_fd5    i2  (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFRHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Reset
//   last modified by : XLICDD generated
//****************************************************************************

module DFFRHDX1 (CN, D, Q, QN, RN);

   input     CN, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_RN, d_clock_i, IQN, c_SH_D;

   not       i1  (d_clock_i, delay_CN);
   u1_fd5    i2  (IQ, delay_D, d_clock_i, delay_RN, 1'b1, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, c_SH_D;

   not       i1  (clock_i, CN);
   u1_fd5    i2  (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFRHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Reset
//   last modified by : XLICDD generated
//****************************************************************************

module DFFRHDX2 (CN, D, Q, QN, RN);

   input     CN, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_RN, d_clock_i, IQN, c_SH_D;

   not       i1  (d_clock_i, delay_CN);
   u1_fd5    i2  (IQ, delay_D, d_clock_i, delay_RN, 1'b1, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, c_SH_D;

   not       i1  (clock_i, CN);
   u1_fd5    i2  (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFRHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Reset
//   last modified by : XLICDD generated
//****************************************************************************

module DFFRHDX4 (CN, D, Q, QN, RN);

   input     CN, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_RN, d_clock_i, IQN, c_SH_D;

   not       i1  (d_clock_i, delay_CN);
   u1_fd5    i2  (IQ, delay_D, d_clock_i, delay_RN, 1'b1, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, c_SH_D;

   not       i1  (clock_i, CN);
   u1_fd5    i2  (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFRQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Reset
//   last modified by : XLICDD generated
//****************************************************************************

module DFFRQHDX0 (CN, D, Q, RN);

   input     CN, D, RN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_RN, d_clock_i, c_SH_D;

   not       i1  (d_clock_i, delay_CN);
   u1_fd5    i2  (IQ, delay_D, d_clock_i, delay_RN, 1'b1, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i1  (clock_i, CN);
   u1_fd5    i2  (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFRQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Reset
//   last modified by : XLICDD generated
//****************************************************************************

module DFFRQHDX1 (CN, D, Q, RN);

   input     CN, D, RN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_RN, d_clock_i, c_SH_D;

   not       i1  (d_clock_i, delay_CN);
   u1_fd5    i2  (IQ, delay_D, d_clock_i, delay_RN, 1'b1, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i1  (clock_i, CN);
   u1_fd5    i2  (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFRQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Reset
//   last modified by : XLICDD generated
//****************************************************************************

module DFFRQHDX2 (CN, D, Q, RN);

   input     CN, D, RN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_RN, d_clock_i, c_SH_D;

   not       i1  (d_clock_i, delay_CN);
   u1_fd5    i2  (IQ, delay_D, d_clock_i, delay_RN, 1'b1, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i1  (clock_i, CN);
   u1_fd5    i2  (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFRQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Reset
//   last modified by : XLICDD generated
//****************************************************************************

module DFFRQHDX4 (CN, D, Q, RN);

   input     CN, D, RN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_RN, d_clock_i, c_SH_D;

   not       i1  (d_clock_i, delay_CN);
   u1_fd5    i2  (IQ, delay_D, d_clock_i, delay_RN, 1'b1, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i1  (clock_i, CN);
   u1_fd5    i2  (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFRSHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Reset and Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFFRSHDX0 (CN, D, Q, QN, RN, SN);

   input     CN, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_RN, delay_SN, d_clock_i, IQN,
                   qin_and_set, c_SH_D;

   not       i1  (d_clock_i, delay_CN);
   u1_fd5    i3  (IQ, delay_D, d_clock_i, delay_RN, delay_SN, NOTIFY_REG);
   not       i4  (IQN, IQ);
   and       i5  (qin_and_set, IQN, delay_SN);
   buf       i6  (Q, IQ);
   buf       i7  (QN, qin_and_set);

   checkrs   i8  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, qin_and_set, c_SH_D;

   not       i1  (clock_i, CN);
   u1_fd5    i3  (IQ, D, clock_i, RN, SN, NOTIFY_REG);
   not       i4  (IQN, IQ);
   and       i5  (qin_and_set, IQN, SN);
   buf       i6  (Q, IQ);
   buf       i7  (QN, qin_and_set);

   checkrs   i8  (c_SH_D, RN, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFRSHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Reset and Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFFRSHDX1 (CN, D, Q, QN, RN, SN);

   input     CN, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_RN, delay_SN, d_clock_i, IQN,
                   qin_and_set, c_SH_D;

   not       i1  (d_clock_i, delay_CN);
   u1_fd5    i3  (IQ, delay_D, d_clock_i, delay_RN, delay_SN, NOTIFY_REG);
   not       i4  (IQN, IQ);
   and       i5  (qin_and_set, IQN, delay_SN);
   buf       i6  (Q, IQ);
   buf       i7  (QN, qin_and_set);

   checkrs   i8  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, qin_and_set, c_SH_D;

   not       i1  (clock_i, CN);
   u1_fd5    i3  (IQ, D, clock_i, RN, SN, NOTIFY_REG);
   not       i4  (IQN, IQ);
   and       i5  (qin_and_set, IQN, SN);
   buf       i6  (Q, IQ);
   buf       i7  (QN, qin_and_set);

   checkrs   i8  (c_SH_D, RN, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFRSHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Reset and Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFFRSHDX2 (CN, D, Q, QN, RN, SN);

   input     CN, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_RN, delay_SN, d_clock_i, IQN,
                   qin_and_set, c_SH_D;

   not       i1  (d_clock_i, delay_CN);
   u1_fd5    i3  (IQ, delay_D, d_clock_i, delay_RN, delay_SN, NOTIFY_REG);
   not       i4  (IQN, IQ);
   and       i5  (qin_and_set, IQN, delay_SN);
   buf       i6  (Q, IQ);
   buf       i7  (QN, qin_and_set);

   checkrs   i8  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, qin_and_set, c_SH_D;

   not       i1  (clock_i, CN);
   u1_fd5    i3  (IQ, D, clock_i, RN, SN, NOTIFY_REG);
   not       i4  (IQN, IQ);
   and       i5  (qin_and_set, IQN, SN);
   buf       i6  (Q, IQ);
   buf       i7  (QN, qin_and_set);

   checkrs   i8  (c_SH_D, RN, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFRSHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Reset and Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFFRSHDX4 (CN, D, Q, QN, RN, SN);

   input     CN, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_RN, delay_SN, d_clock_i, IQN,
                   qin_and_set, c_SH_D;

   not       i1  (d_clock_i, delay_CN);
   u1_fd5    i3  (IQ, delay_D, d_clock_i, delay_RN, delay_SN, NOTIFY_REG);
   not       i4  (IQN, IQ);
   and       i5  (qin_and_set, IQN, delay_SN);
   buf       i6  (Q, IQ);
   buf       i7  (QN, qin_and_set);

   checkrs   i8  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, qin_and_set, c_SH_D;

   not       i1  (clock_i, CN);
   u1_fd5    i3  (IQ, D, clock_i, RN, SN, NOTIFY_REG);
   not       i4  (IQN, IQ);
   and       i5  (qin_and_set, IQN, SN);
   buf       i6  (Q, IQ);
   buf       i7  (QN, qin_and_set);

   checkrs   i8  (c_SH_D, RN, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFRSQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFFRSQHDX0 (CN, D, Q, RN, SN);

   input     CN, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_RN, delay_SN, d_clock_i, c_SH_D;

   not       i1  (d_clock_i, delay_CN);
   u1_fd5    i3  (IQ, delay_D, d_clock_i, delay_RN, delay_SN, NOTIFY_REG);
   buf       i4  (Q, IQ);

   checkrs   i5  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i1  (clock_i, CN);
   u1_fd5    i3  (IQ, D, clock_i, RN, SN, NOTIFY_REG);
   buf       i4  (Q, IQ);

   checkrs   i5  (c_SH_D, RN, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFRSQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFFRSQHDX1 (CN, D, Q, RN, SN);

   input     CN, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_RN, delay_SN, d_clock_i, c_SH_D;

   not       i1  (d_clock_i, delay_CN);
   u1_fd5    i3  (IQ, delay_D, d_clock_i, delay_RN, delay_SN, NOTIFY_REG);
   buf       i4  (Q, IQ);

   checkrs   i5  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i1  (clock_i, CN);
   u1_fd5    i3  (IQ, D, clock_i, RN, SN, NOTIFY_REG);
   buf       i4  (Q, IQ);

   checkrs   i5  (c_SH_D, RN, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFRSQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFFRSQHDX2 (CN, D, Q, RN, SN);

   input     CN, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_RN, delay_SN, d_clock_i, c_SH_D;

   not       i1  (d_clock_i, delay_CN);
   u1_fd5    i3  (IQ, delay_D, d_clock_i, delay_RN, delay_SN, NOTIFY_REG);
   buf       i4  (Q, IQ);

   checkrs   i5  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i1  (clock_i, CN);
   u1_fd5    i3  (IQ, D, clock_i, RN, SN, NOTIFY_REG);
   buf       i4  (Q, IQ);

   checkrs   i5  (c_SH_D, RN, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFRSQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFFRSQHDX4 (CN, D, Q, RN, SN);

   input     CN, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_RN, delay_SN, d_clock_i, c_SH_D;

   not       i1  (d_clock_i, delay_CN);
   u1_fd5    i3  (IQ, delay_D, d_clock_i, delay_RN, delay_SN, NOTIFY_REG);
   buf       i4  (Q, IQ);

   checkrs   i5  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i1  (clock_i, CN);
   u1_fd5    i3  (IQ, D, clock_i, RN, SN, NOTIFY_REG);
   buf       i4  (Q, IQ);

   checkrs   i5  (c_SH_D, RN, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFSHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFFSHDX0 (CN, D, Q, QN, SN);

   input     CN, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SN, d_clock_i, IQN, c_SH_D;

   not       i0  (d_clock_i, delay_CN);
   u1_fd5    i2  (IQ, delay_D, d_clock_i, 1'b1, delay_SN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, c_SH_D;

   not       i0  (clock_i, CN);
   u1_fd5    i2  (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFSHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFFSHDX1 (CN, D, Q, QN, SN);

   input     CN, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SN, d_clock_i, IQN, c_SH_D;

   not       i0  (d_clock_i, delay_CN);
   u1_fd5    i2  (IQ, delay_D, d_clock_i, 1'b1, delay_SN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, c_SH_D;

   not       i0  (clock_i, CN);
   u1_fd5    i2  (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFSHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFFSHDX2 (CN, D, Q, QN, SN);

   input     CN, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SN, d_clock_i, IQN, c_SH_D;

   not       i0  (d_clock_i, delay_CN);
   u1_fd5    i2  (IQ, delay_D, d_clock_i, 1'b1, delay_SN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, c_SH_D;

   not       i0  (clock_i, CN);
   u1_fd5    i2  (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFSHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFFSHDX4 (CN, D, Q, QN, SN);

   input     CN, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SN, d_clock_i, IQN, c_SH_D;

   not       i0  (d_clock_i, delay_CN);
   u1_fd5    i2  (IQ, delay_D, d_clock_i, 1'b1, delay_SN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, c_SH_D;

   not       i0  (clock_i, CN);
   u1_fd5    i2  (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFSQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFFSQHDX0 (CN, D, Q, SN);

   input     CN, D, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SN, d_clock_i, c_SH_D;

   not       i0  (d_clock_i, delay_CN);
   u1_fd5    i2  (IQ, delay_D, d_clock_i, 1'b1, delay_SN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i0  (clock_i, CN);
   u1_fd5    i2  (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFSQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFFSQHDX1 (CN, D, Q, SN);

   input     CN, D, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SN, d_clock_i, c_SH_D;

   not       i0  (d_clock_i, delay_CN);
   u1_fd5    i2  (IQ, delay_D, d_clock_i, 1'b1, delay_SN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i0  (clock_i, CN);
   u1_fd5    i2  (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFSQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFFSQHDX2 (CN, D, Q, SN);

   input     CN, D, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SN, d_clock_i, c_SH_D;

   not       i0  (d_clock_i, delay_CN);
   u1_fd5    i2  (IQ, delay_D, d_clock_i, 1'b1, delay_SN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i0  (clock_i, CN);
   u1_fd5    i2  (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFFSQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFFSQHDX4 (CN, D, Q, SN);

   input     CN, D, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SN, d_clock_i, c_SH_D;

   not       i0  (d_clock_i, delay_CN);
   u1_fd5    i2  (IQ, delay_D, d_clock_i, 1'b1, delay_SN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i0  (clock_i, CN);
   u1_fd5    i2  (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q +: D)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop
//   last modified by : XLICDD generated
//****************************************************************************

module DFRHDX0 (C, D, Q, QN);

   input     C, D;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, IQN;

   u1_fd5    i0  (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
   not       i1  (IQN, IQ);
   buf       i2  (Q, IQ);
   buf       i3  (QN, IQN);


// timing section:
   specify

      (posedge C => (Q +: D)) = (0.02, 0.02);

      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_D);
      $setuphold (posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_D);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN;

   u1_fd5    i0  (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
   not       i1  (IQN, IQ);
   buf       i2  (Q, IQ);
   buf       i3  (QN, IQN);


// timing section:
   specify

      (posedge C => (Q +: D)) = (0.02, 0.02);

      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop
//   last modified by : XLICDD generated
//****************************************************************************

module DFRHDX1 (C, D, Q, QN);

   input     C, D;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, IQN;

   u1_fd5    i0  (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
   not       i1  (IQN, IQ);
   buf       i2  (Q, IQ);
   buf       i3  (QN, IQN);


// timing section:
   specify

      (posedge C => (Q +: D)) = (0.02, 0.02);

      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_D);
      $setuphold (posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_D);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN;

   u1_fd5    i0  (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
   not       i1  (IQN, IQ);
   buf       i2  (Q, IQ);
   buf       i3  (QN, IQN);


// timing section:
   specify

      (posedge C => (Q +: D)) = (0.02, 0.02);

      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop
//   last modified by : XLICDD generated
//****************************************************************************

module DFRHDX2 (C, D, Q, QN);

   input     C, D;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, IQN;

   u1_fd5    i0  (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
   not       i1  (IQN, IQ);
   buf       i2  (Q, IQ);
   buf       i3  (QN, IQN);


// timing section:
   specify

      (posedge C => (Q +: D)) = (0.02, 0.02);

      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_D);
      $setuphold (posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_D);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN;

   u1_fd5    i0  (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
   not       i1  (IQN, IQ);
   buf       i2  (Q, IQ);
   buf       i3  (QN, IQN);


// timing section:
   specify

      (posedge C => (Q +: D)) = (0.02, 0.02);

      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop
//   last modified by : XLICDD generated
//****************************************************************************

module DFRHDX4 (C, D, Q, QN);

   input     C, D;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, IQN;

   u1_fd5    i0  (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
   not       i1  (IQN, IQ);
   buf       i2  (Q, IQ);
   buf       i3  (QN, IQN);


// timing section:
   specify

      (posedge C => (Q +: D)) = (0.02, 0.02);

      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_D);
      $setuphold (posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_D);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN;

   u1_fd5    i0  (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
   not       i1  (IQN, IQ);
   buf       i2  (Q, IQ);
   buf       i3  (QN, IQN);


// timing section:
   specify

      (posedge C => (Q +: D)) = (0.02, 0.02);

      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop
//   last modified by : XLICDD generated
//****************************************************************************

module DFRQHDX0 (C, D, Q);

   input     C, D;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D;

   u1_fd5    i0  (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
   buf       i1  (Q, IQ);


// timing section:
   specify

      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_D);
      $setuphold (posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_D);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ;

   u1_fd5    i0  (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
   buf       i1  (Q, IQ);


// timing section:
   specify

      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop
//   last modified by : XLICDD generated
//****************************************************************************

module DFRQHDX1 (C, D, Q);

   input     C, D;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D;

   u1_fd5    i0  (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
   buf       i1  (Q, IQ);


// timing section:
   specify

      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_D);
      $setuphold (posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_D);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ;

   u1_fd5    i0  (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
   buf       i1  (Q, IQ);


// timing section:
   specify

      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop
//   last modified by : XLICDD generated
//****************************************************************************

module DFRQHDX2 (C, D, Q);

   input     C, D;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D;

   u1_fd5    i0  (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
   buf       i1  (Q, IQ);


// timing section:
   specify

      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_D);
      $setuphold (posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_D);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ;

   u1_fd5    i0  (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
   buf       i1  (Q, IQ);


// timing section:
   specify

      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop
//   last modified by : XLICDD generated
//****************************************************************************

module DFRQHDX4 (C, D, Q);

   input     C, D;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D;

   u1_fd5    i0  (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
   buf       i1  (Q, IQ);


// timing section:
   specify

      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_D);
      $setuphold (posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_D);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ;

   u1_fd5    i0  (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
   buf       i1  (Q, IQ);


// timing section:
   specify

      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRRHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Reset
//   last modified by : XLICDD generated
//****************************************************************************

module DFRRHDX0 (C, D, Q, QN, RN);

   input     C, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_RN, IQN, c_SH_D;

   u1_fd5    i1  (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, c_SH_D;

   u1_fd5    i1  (IQ, D, C, RN, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRRHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Reset
//   last modified by : XLICDD generated
//****************************************************************************

module DFRRHDX1 (C, D, Q, QN, RN);

   input     C, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_RN, IQN, c_SH_D;

   u1_fd5    i1  (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, c_SH_D;

   u1_fd5    i1  (IQ, D, C, RN, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRRHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Reset
//   last modified by : XLICDD generated
//****************************************************************************

module DFRRHDX2 (C, D, Q, QN, RN);

   input     C, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_RN, IQN, c_SH_D;

   u1_fd5    i1  (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, c_SH_D;

   u1_fd5    i1  (IQ, D, C, RN, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRRHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Reset
//   last modified by : XLICDD generated
//****************************************************************************

module DFRRHDX4 (C, D, Q, QN, RN);

   input     C, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_RN, IQN, c_SH_D;

   u1_fd5    i1  (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, c_SH_D;

   u1_fd5    i1  (IQ, D, C, RN, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRRQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Reset
//   last modified by : XLICDD generated
//****************************************************************************

module DFRRQHDX0 (C, D, Q, RN);

   input     C, D, RN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_RN, c_SH_D;

   u1_fd5    i1  (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u1_fd5    i1  (IQ, D, C, RN, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRRQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Reset
//   last modified by : XLICDD generated
//****************************************************************************

module DFRRQHDX1 (C, D, Q, RN);

   input     C, D, RN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_RN, c_SH_D;

   u1_fd5    i1  (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u1_fd5    i1  (IQ, D, C, RN, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRRQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Reset
//   last modified by : XLICDD generated
//****************************************************************************

module DFRRQHDX2 (C, D, Q, RN);

   input     C, D, RN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_RN, c_SH_D;

   u1_fd5    i1  (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u1_fd5    i1  (IQ, D, C, RN, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRRQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Reset
//   last modified by : XLICDD generated
//****************************************************************************

module DFRRQHDX4 (C, D, Q, RN);

   input     C, D, RN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_RN, c_SH_D;

   u1_fd5    i1  (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u1_fd5    i1  (IQ, D, C, RN, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRRSHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Reset and Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFRRSHDX0 (C, D, Q, QN, RN, SN);

   input     C, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_RN, delay_SN, IQN, qin_and_set,
                   c_SH_D;

   u1_fd5    i2  (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   and       i4  (qin_and_set, IQN, delay_SN);
   buf       i5  (Q, IQ);
   buf       i6  (QN, qin_and_set);

   checkrs   i7  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, qin_and_set, c_SH_D;

   u1_fd5    i2  (IQ, D, C, RN, SN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   and       i4  (qin_and_set, IQN, SN);
   buf       i5  (Q, IQ);
   buf       i6  (QN, qin_and_set);

   checkrs   i7  (c_SH_D, RN, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRRSHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Reset and Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFRRSHDX1 (C, D, Q, QN, RN, SN);

   input     C, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_RN, delay_SN, IQN, qin_and_set,
                   c_SH_D;

   u1_fd5    i2  (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   and       i4  (qin_and_set, IQN, delay_SN);
   buf       i5  (Q, IQ);
   buf       i6  (QN, qin_and_set);

   checkrs   i7  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, qin_and_set, c_SH_D;

   u1_fd5    i2  (IQ, D, C, RN, SN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   and       i4  (qin_and_set, IQN, SN);
   buf       i5  (Q, IQ);
   buf       i6  (QN, qin_and_set);

   checkrs   i7  (c_SH_D, RN, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRRSHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Reset and Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFRRSHDX2 (C, D, Q, QN, RN, SN);

   input     C, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_RN, delay_SN, IQN, qin_and_set,
                   c_SH_D;

   u1_fd5    i2  (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   and       i4  (qin_and_set, IQN, delay_SN);
   buf       i5  (Q, IQ);
   buf       i6  (QN, qin_and_set);

   checkrs   i7  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, qin_and_set, c_SH_D;

   u1_fd5    i2  (IQ, D, C, RN, SN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   and       i4  (qin_and_set, IQN, SN);
   buf       i5  (Q, IQ);
   buf       i6  (QN, qin_and_set);

   checkrs   i7  (c_SH_D, RN, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRRSHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Reset and Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFRRSHDX4 (C, D, Q, QN, RN, SN);

   input     C, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_RN, delay_SN, IQN, qin_and_set,
                   c_SH_D;

   u1_fd5    i2  (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   and       i4  (qin_and_set, IQN, delay_SN);
   buf       i5  (Q, IQ);
   buf       i6  (QN, qin_and_set);

   checkrs   i7  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, qin_and_set, c_SH_D;

   u1_fd5    i2  (IQ, D, C, RN, SN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   and       i4  (qin_and_set, IQN, SN);
   buf       i5  (Q, IQ);
   buf       i6  (QN, qin_and_set);

   checkrs   i7  (c_SH_D, RN, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRRSQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFRRSQHDX0 (C, D, Q, RN, SN);

   input     C, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_RN, delay_SN, c_SH_D;

   u1_fd5    i2  (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u1_fd5    i2  (IQ, D, C, RN, SN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, RN, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRRSQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFRRSQHDX1 (C, D, Q, RN, SN);

   input     C, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_RN, delay_SN, c_SH_D;

   u1_fd5    i2  (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u1_fd5    i2  (IQ, D, C, RN, SN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, RN, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRRSQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFRRSQHDX2 (C, D, Q, RN, SN);

   input     C, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_RN, delay_SN, c_SH_D;

   u1_fd5    i2  (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u1_fd5    i2  (IQ, D, C, RN, SN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, RN, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRRSQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFRRSQHDX4 (C, D, Q, RN, SN);

   input     C, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_RN, delay_SN, c_SH_D;

   u1_fd5    i2  (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u1_fd5    i2  (IQ, D, C, RN, SN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, RN, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRSHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFRSHDX0 (C, D, Q, QN, SN);

   input     C, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SN, IQN, c_SH_D;

   u1_fd5    i1  (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, c_SH_D;

   u1_fd5    i1  (IQ, D, C, 1'b1, SN, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRSHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFRSHDX1 (C, D, Q, QN, SN);

   input     C, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SN, IQN, c_SH_D;

   u1_fd5    i1  (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, c_SH_D;

   u1_fd5    i1  (IQ, D, C, 1'b1, SN, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRSHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFRSHDX2 (C, D, Q, QN, SN);

   input     C, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SN, IQN, c_SH_D;

   u1_fd5    i1  (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, c_SH_D;

   u1_fd5    i1  (IQ, D, C, 1'b1, SN, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRSHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFRSHDX4 (C, D, Q, QN, SN);

   input     C, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SN, IQN, c_SH_D;

   u1_fd5    i1  (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, c_SH_D;

   u1_fd5    i1  (IQ, D, C, 1'b1, SN, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRSQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFRSQHDX0 (C, D, Q, SN);

   input     C, D, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SN, c_SH_D;

   u1_fd5    i1  (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u1_fd5    i1  (IQ, D, C, 1'b1, SN, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRSQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFRSQHDX1 (C, D, Q, SN);

   input     C, D, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SN, c_SH_D;

   u1_fd5    i1  (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u1_fd5    i1  (IQ, D, C, 1'b1, SN, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRSQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFRSQHDX2 (C, D, Q, SN);

   input     C, D, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SN, c_SH_D;

   u1_fd5    i1  (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u1_fd5    i1  (IQ, D, C, 1'b1, SN, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DFRSQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Set
//   last modified by : XLICDD generated
//****************************************************************************

module DFRSQHDX4 (C, D, Q, SN);

   input     C, D, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SN, c_SH_D;

   u1_fd5    i1  (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u1_fd5    i1  (IQ, D, C, 1'b1, SN, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q +: D)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active transparent D-latch
//   last modified by : XLICDD generated
//****************************************************************************

module DLHHDX0 (D, G, Q, QN);

   input     D, G;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, IQN;

   u_ld6     i0  (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
   not       i1  (IQN, IQ);
   buf       i2  (Q, IQ);
   buf       i3  (QN, IQN);


// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G,
                   delay_D);
      $setuphold (negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G,
                   delay_D);

      $width (posedge G, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN;

   u_ld6     i0  (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
   not       i1  (IQN, IQ);
   buf       i2  (Q, IQ);
   buf       i3  (QN, IQN);


// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active transparent D-latch
//   last modified by : XLICDD generated
//****************************************************************************

module DLHHDX1 (D, G, Q, QN);

   input     D, G;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, IQN;

   u_ld6     i0  (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
   not       i1  (IQN, IQ);
   buf       i2  (Q, IQ);
   buf       i3  (QN, IQN);


// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G,
                   delay_D);
      $setuphold (negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G,
                   delay_D);

      $width (posedge G, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN;

   u_ld6     i0  (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
   not       i1  (IQN, IQ);
   buf       i2  (Q, IQ);
   buf       i3  (QN, IQN);


// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active transparent D-latch
//   last modified by : XLICDD generated
//****************************************************************************

module DLHHDX2 (D, G, Q, QN);

   input     D, G;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, IQN;

   u_ld6     i0  (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
   not       i1  (IQN, IQ);
   buf       i2  (Q, IQ);
   buf       i3  (QN, IQN);


// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G,
                   delay_D);
      $setuphold (negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G,
                   delay_D);

      $width (posedge G, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN;

   u_ld6     i0  (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
   not       i1  (IQN, IQ);
   buf       i2  (Q, IQ);
   buf       i3  (QN, IQN);


// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active transparent D-latch
//   last modified by : XLICDD generated
//****************************************************************************

module DLHHDX4 (D, G, Q, QN);

   input     D, G;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, IQN;

   u_ld6     i0  (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
   not       i1  (IQN, IQ);
   buf       i2  (Q, IQ);
   buf       i3  (QN, IQN);


// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G,
                   delay_D);
      $setuphold (negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G,
                   delay_D);

      $width (posedge G, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN;

   u_ld6     i0  (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
   not       i1  (IQN, IQ);
   buf       i2  (Q, IQ);
   buf       i3  (QN, IQN);


// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active single Q transparent D-latch
//   last modified by : XLICDD generated
//****************************************************************************

module DLHQHDX0 (D, G, Q);

   input     D, G;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D;

   u_ld6     i0  (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
   buf       i1  (Q, IQ);


// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G,
                   delay_D);
      $setuphold (negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G,
                   delay_D);

      $width (posedge G, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ;

   u_ld6     i0  (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
   buf       i1  (Q, IQ);


// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active single Q transparent D-latch
//   last modified by : XLICDD generated
//****************************************************************************

module DLHQHDX1 (D, G, Q);

   input     D, G;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D;

   u_ld6     i0  (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
   buf       i1  (Q, IQ);


// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G,
                   delay_D);
      $setuphold (negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G,
                   delay_D);

      $width (posedge G, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ;

   u_ld6     i0  (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
   buf       i1  (Q, IQ);


// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active single Q transparent D-latch
//   last modified by : XLICDD generated
//****************************************************************************

module DLHQHDX2 (D, G, Q);

   input     D, G;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D;

   u_ld6     i0  (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
   buf       i1  (Q, IQ);


// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G,
                   delay_D);
      $setuphold (negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G,
                   delay_D);

      $width (posedge G, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ;

   u_ld6     i0  (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
   buf       i1  (Q, IQ);


// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active single Q transparent D-latch
//   last modified by : XLICDD generated
//****************************************************************************

module DLHQHDX4 (D, G, Q);

   input     D, G;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D;

   u_ld6     i0  (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
   buf       i1  (Q, IQ);


// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G,
                   delay_D);
      $setuphold (negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G,
                   delay_D);

      $width (posedge G, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ;

   u_ld6     i0  (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
   buf       i1  (Q, IQ);


// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHRHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active transparent D-latch with reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLHRHDX0 (D, G, Q, QN, RN);

   input     D, G, RN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_RN, IQN, c_SH_D;

   u_ld6     i1  (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, c_SH_D;

   u_ld6     i1  (IQ, D, G, 1'b1, RN, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHRHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active transparent D-latch with reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLHRHDX1 (D, G, Q, QN, RN);

   input     D, G, RN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_RN, IQN, c_SH_D;

   u_ld6     i1  (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, c_SH_D;

   u_ld6     i1  (IQ, D, G, 1'b1, RN, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHRHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active transparent D-latch with reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLHRHDX2 (D, G, Q, QN, RN);

   input     D, G, RN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_RN, IQN, c_SH_D;

   u_ld6     i1  (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, c_SH_D;

   u_ld6     i1  (IQ, D, G, 1'b1, RN, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHRHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active transparent D-latch with reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLHRHDX4 (D, G, Q, QN, RN);

   input     D, G, RN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_RN, IQN, c_SH_D;

   u_ld6     i1  (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, c_SH_D;

   u_ld6     i1  (IQ, D, G, 1'b1, RN, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHRQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active single Q transparent D-latch with reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLHRQHDX0 (D, G, Q, RN);

   input     D, G, RN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_RN, c_SH_D;

   u_ld6     i1  (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u_ld6     i1  (IQ, D, G, 1'b1, RN, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHRQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active single Q transparent D-latch with reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLHRQHDX1 (D, G, Q, RN);

   input     D, G, RN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_RN, c_SH_D;

   u_ld6     i1  (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u_ld6     i1  (IQ, D, G, 1'b1, RN, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHRQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active single Q transparent D-latch with reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLHRQHDX2 (D, G, Q, RN);

   input     D, G, RN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_RN, c_SH_D;

   u_ld6     i1  (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u_ld6     i1  (IQ, D, G, 1'b1, RN, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHRQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active single Q transparent D-latch with reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLHRQHDX4 (D, G, Q, RN);

   input     D, G, RN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_RN, c_SH_D;

   u_ld6     i1  (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u_ld6     i1  (IQ, D, G, 1'b1, RN, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHRSHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active transparent D-latch with set and reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLHRSHDX0 (D, G, Q, QN, RN, SN);

   input     D, G, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_RN, delay_SN, IQN, c_SH_D;

   u_ld6     i2  (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_G);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, c_SH_D;

   u_ld6     i2  (IQ, D, G, SN, RN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, RN, SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHRSHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active transparent D-latch with set and reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLHRSHDX1 (D, G, Q, QN, RN, SN);

   input     D, G, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_RN, delay_SN, IQN, c_SH_D;

   u_ld6     i2  (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_G);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, c_SH_D;

   u_ld6     i2  (IQ, D, G, SN, RN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, RN, SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHRSHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active transparent D-latch with set and reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLHRSHDX2 (D, G, Q, QN, RN, SN);

   input     D, G, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_RN, delay_SN, IQN, c_SH_D;

   u_ld6     i2  (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_G);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, c_SH_D;

   u_ld6     i2  (IQ, D, G, SN, RN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, RN, SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHRSHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active transparent D-latch with set and reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLHRSHDX4 (D, G, Q, QN, RN, SN);

   input     D, G, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_RN, delay_SN, IQN, c_SH_D;

   u_ld6     i2  (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_G);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, c_SH_D;

   u_ld6     i2  (IQ, D, G, SN, RN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, RN, SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHRSQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active single Q transparent D-latch with set
//                      and reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLHRSQHDX0 (D, G, Q, RN, SN);

   input     D, G, RN, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_RN, delay_SN, c_SH_D;

   u_ld6     i2  (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_G);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u_ld6     i2  (IQ, D, G, SN, RN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, RN, SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHRSQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active single Q transparent D-latch with set
//                      and reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLHRSQHDX1 (D, G, Q, RN, SN);

   input     D, G, RN, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_RN, delay_SN, c_SH_D;

   u_ld6     i2  (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_G);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u_ld6     i2  (IQ, D, G, SN, RN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, RN, SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHRSQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active single Q transparent D-latch with set
//                      and reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLHRSQHDX2 (D, G, Q, RN, SN);

   input     D, G, RN, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_RN, delay_SN, c_SH_D;

   u_ld6     i2  (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_G);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u_ld6     i2  (IQ, D, G, SN, RN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, RN, SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHRSQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active single Q transparent D-latch with set
//                      and reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLHRSQHDX4 (D, G, Q, RN, SN);

   input     D, G, RN, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_RN, delay_SN, c_SH_D;

   u_ld6     i2  (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_G);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u_ld6     i2  (IQ, D, G, SN, RN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, RN, SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHRTHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active transparent D-latch with reset;
//                      tristate Q Buffer with active low enable
//   last modified by : XLICDD generated
//****************************************************************************

module DLHRTHDX1 (D, EN, G, Q, RN);

   input     D, EN, G, RN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_RN, c_SH_D;

   u_ld6     i1  (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
   bufif0    i2  (Q, IQ, EN);

   checkrs   i3  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u_ld6     i1  (IQ, D, G, 1'b1, RN, NOTIFY_REG);
   bufif0    i2  (Q, IQ, EN);

   checkrs   i3  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHSHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active transparent D-latch with set
//   last modified by : XLICDD generated
//****************************************************************************

module DLHSHDX0 (D, G, Q, QN, SN);

   input     D, G, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_SN, IQN, c_SH_D;

   u_ld6     i1  (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, c_SH_D;

   u_ld6     i1  (IQ, D, G, SN, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHSHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active transparent D-latch with set
//   last modified by : XLICDD generated
//****************************************************************************

module DLHSHDX1 (D, G, Q, QN, SN);

   input     D, G, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_SN, IQN, c_SH_D;

   u_ld6     i1  (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, c_SH_D;

   u_ld6     i1  (IQ, D, G, SN, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHSHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active transparent D-latch with set
//   last modified by : XLICDD generated
//****************************************************************************

module DLHSHDX2 (D, G, Q, QN, SN);

   input     D, G, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_SN, IQN, c_SH_D;

   u_ld6     i1  (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, c_SH_D;

   u_ld6     i1  (IQ, D, G, SN, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHSHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active transparent D-latch with set
//   last modified by : XLICDD generated
//****************************************************************************

module DLHSHDX4 (D, G, Q, QN, SN);

   input     D, G, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_SN, IQN, c_SH_D;

   u_ld6     i1  (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, IQN, c_SH_D;

   u_ld6     i1  (IQ, D, G, SN, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);

   checkrs   i5  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (posedge G => (QN -: QN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHSQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active single Q transparent D-latch with set
//   last modified by : XLICDD generated
//****************************************************************************

module DLHSQHDX0 (D, G, Q, SN);

   input     D, G, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_SN, c_SH_D;

   u_ld6     i1  (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u_ld6     i1  (IQ, D, G, SN, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHSQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active single Q transparent D-latch with set
//   last modified by : XLICDD generated
//****************************************************************************

module DLHSQHDX1 (D, G, Q, SN);

   input     D, G, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_SN, c_SH_D;

   u_ld6     i1  (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u_ld6     i1  (IQ, D, G, SN, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHSQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active single Q transparent D-latch with set
//   last modified by : XLICDD generated
//****************************************************************************

module DLHSQHDX2 (D, G, Q, SN);

   input     D, G, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_SN, c_SH_D;

   u_ld6     i1  (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u_ld6     i1  (IQ, D, G, SN, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHSQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active single Q transparent D-latch with set
//   last modified by : XLICDD generated
//****************************************************************************

module DLHSQHDX4 (D, G, Q, SN);

   input     D, G, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_SN, c_SH_D;

   u_ld6     i1  (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u_ld6     i1  (IQ, D, G, SN, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);

   checkrs   i3  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHSTHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active transparent D-latch with set; tristate
//                      Q Buffer with active low enable
//   last modified by : XLICDD generated
//****************************************************************************

module DLHSTHDX1 (D, EN, G, Q, SN);

   input     D, EN, G, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D, delay_SN, c_SH_D;

   u_ld6     i1  (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
   bufif0    i2  (Q, IQ, EN);

   checkrs   i3  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_G, delay_D);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_G);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, c_SH_D;

   u_ld6     i1  (IQ, D, G, SN, 1'b1, NOTIFY_REG);
   bufif0    i2  (Q, IQ, EN);

   checkrs   i3  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

      $setuphold (negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLHTHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : high active transparent D-latch; tristate Q Buffer
//                      with active low enable
//   last modified by : XLICDD generated
//****************************************************************************

module DLHTHDX1 (D, EN, G, Q);

   input     D, EN, G;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_G, delay_D;

   u_ld6     i0  (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
   bufif0    i1  (Q, IQ, EN);


// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

      $setuphold (negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G,
                   delay_D);
      $setuphold (negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G,
                   delay_D);

      $width (posedge G, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ;

   u_ld6     i0  (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
   bufif0    i1  (Q, IQ, EN);


// timing section:
   specify

      (posedge G => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

      $setuphold (negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (posedge G, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active transparent D-latch
//   last modified by : XLICDD generated
//****************************************************************************

module DLLHDX0 (D, GN, Q, QN);

   input     D, GN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, d_clock_i, IQN;

   not       i0  (d_clock_i, delay_GN);
   u_ld6     i1  (IQ, delay_D, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);


// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN,
                   delay_D);
      $setuphold (posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN,
                   delay_D);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN;

   not       i0  (clock_i, GN);
   u_ld6     i1  (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);


// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active transparent D-latch
//   last modified by : XLICDD generated
//****************************************************************************

module DLLHDX1 (D, GN, Q, QN);

   input     D, GN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, d_clock_i, IQN;

   not       i0  (d_clock_i, delay_GN);
   u_ld6     i1  (IQ, delay_D, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);


// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN,
                   delay_D);
      $setuphold (posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN,
                   delay_D);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN;

   not       i0  (clock_i, GN);
   u_ld6     i1  (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);


// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active transparent D-latch
//   last modified by : XLICDD generated
//****************************************************************************

module DLLHDX2 (D, GN, Q, QN);

   input     D, GN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, d_clock_i, IQN;

   not       i0  (d_clock_i, delay_GN);
   u_ld6     i1  (IQ, delay_D, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);


// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN,
                   delay_D);
      $setuphold (posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN,
                   delay_D);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN;

   not       i0  (clock_i, GN);
   u_ld6     i1  (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);


// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active transparent D-latch
//   last modified by : XLICDD generated
//****************************************************************************

module DLLHDX4 (D, GN, Q, QN);

   input     D, GN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, d_clock_i, IQN;

   not       i0  (d_clock_i, delay_GN);
   u_ld6     i1  (IQ, delay_D, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);


// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN,
                   delay_D);
      $setuphold (posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN,
                   delay_D);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN;

   not       i0  (clock_i, GN);
   u_ld6     i1  (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i2  (IQN, IQ);
   buf       i3  (Q, IQ);
   buf       i4  (QN, IQN);


// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active single Q transparent D-latch
//   last modified by : XLICDD generated
//****************************************************************************

module DLLQHDX0 (D, GN, Q);

   input     D, GN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, d_clock_i;

   not       i0  (d_clock_i, delay_GN);
   u_ld6     i1  (IQ, delay_D, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);


// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN,
                   delay_D);
      $setuphold (posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN,
                   delay_D);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i;

   not       i0  (clock_i, GN);
   u_ld6     i1  (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);


// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active single Q transparent D-latch
//   last modified by : XLICDD generated
//****************************************************************************

module DLLQHDX1 (D, GN, Q);

   input     D, GN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, d_clock_i;

   not       i0  (d_clock_i, delay_GN);
   u_ld6     i1  (IQ, delay_D, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);


// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN,
                   delay_D);
      $setuphold (posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN,
                   delay_D);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i;

   not       i0  (clock_i, GN);
   u_ld6     i1  (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);


// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active single Q transparent D-latch
//   last modified by : XLICDD generated
//****************************************************************************

module DLLQHDX2 (D, GN, Q);

   input     D, GN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, d_clock_i;

   not       i0  (d_clock_i, delay_GN);
   u_ld6     i1  (IQ, delay_D, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);


// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN,
                   delay_D);
      $setuphold (posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN,
                   delay_D);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i;

   not       i0  (clock_i, GN);
   u_ld6     i1  (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);


// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active single Q transparent D-latch
//   last modified by : XLICDD generated
//****************************************************************************

module DLLQHDX4 (D, GN, Q);

   input     D, GN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, d_clock_i;

   not       i0  (d_clock_i, delay_GN);
   u_ld6     i1  (IQ, delay_D, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);


// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN,
                   delay_D);
      $setuphold (posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN,
                   delay_D);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i;

   not       i0  (clock_i, GN);
   u_ld6     i1  (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i2  (Q, IQ);


// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLRHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active transparent D-latch with reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLLRHDX0 (D, GN, Q, QN, RN);

   input     D, GN, RN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_RN, d_clock_i, IQN, c_SH_D;

   not       i1  (d_clock_i, delay_GN);
   u_ld6     i2  (IQ, delay_D, d_clock_i, 1'b1, delay_RN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, c_SH_D;

   not       i1  (clock_i, GN);
   u_ld6     i2  (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLRHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active transparent D-latch with reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLLRHDX1 (D, GN, Q, QN, RN);

   input     D, GN, RN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_RN, d_clock_i, IQN, c_SH_D;

   not       i1  (d_clock_i, delay_GN);
   u_ld6     i2  (IQ, delay_D, d_clock_i, 1'b1, delay_RN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, c_SH_D;

   not       i1  (clock_i, GN);
   u_ld6     i2  (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLRHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active transparent D-latch with reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLLRHDX2 (D, GN, Q, QN, RN);

   input     D, GN, RN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_RN, d_clock_i, IQN, c_SH_D;

   not       i1  (d_clock_i, delay_GN);
   u_ld6     i2  (IQ, delay_D, d_clock_i, 1'b1, delay_RN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, c_SH_D;

   not       i1  (clock_i, GN);
   u_ld6     i2  (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLRHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active transparent D-latch with reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLLRHDX4 (D, GN, Q, QN, RN);

   input     D, GN, RN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_RN, d_clock_i, IQN, c_SH_D;

   not       i1  (d_clock_i, delay_GN);
   u_ld6     i2  (IQ, delay_D, d_clock_i, 1'b1, delay_RN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, c_SH_D;

   not       i1  (clock_i, GN);
   u_ld6     i2  (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLRQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active single Q transparent D-latch with reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLLRQHDX0 (D, GN, Q, RN);

   input     D, GN, RN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_RN, d_clock_i, c_SH_D;

   not       i1  (d_clock_i, delay_GN);
   u_ld6     i2  (IQ, delay_D, d_clock_i, 1'b1, delay_RN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i1  (clock_i, GN);
   u_ld6     i2  (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLRQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active single Q transparent D-latch with reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLLRQHDX1 (D, GN, Q, RN);

   input     D, GN, RN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_RN, d_clock_i, c_SH_D;

   not       i1  (d_clock_i, delay_GN);
   u_ld6     i2  (IQ, delay_D, d_clock_i, 1'b1, delay_RN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i1  (clock_i, GN);
   u_ld6     i2  (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLRQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active single Q transparent D-latch with reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLLRQHDX2 (D, GN, Q, RN);

   input     D, GN, RN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_RN, d_clock_i, c_SH_D;

   not       i1  (d_clock_i, delay_GN);
   u_ld6     i2  (IQ, delay_D, d_clock_i, 1'b1, delay_RN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i1  (clock_i, GN);
   u_ld6     i2  (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLRQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active single Q transparent D-latch with reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLLRQHDX4 (D, GN, Q, RN);

   input     D, GN, RN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_RN, d_clock_i, c_SH_D;

   not       i1  (d_clock_i, delay_GN);
   u_ld6     i2  (IQ, delay_D, d_clock_i, 1'b1, delay_RN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i1  (clock_i, GN);
   u_ld6     i2  (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLRSHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active transparent D-latch with set and reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLLRSHDX0 (D, GN, Q, QN, RN, SN);

   input     D, GN, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_RN, delay_SN, d_clock_i, IQN,
                   c_SH_D;

   not       i1  (d_clock_i, delay_GN);
   u_ld6     i3  (IQ, delay_D, d_clock_i, delay_SN, delay_RN, NOTIFY_REG);
   not       i4  (IQN, IQ);
   buf       i5  (Q, IQ);
   buf       i6  (QN, IQN);

   checkrs   i7  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_GN);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, c_SH_D;

   not       i1  (clock_i, GN);
   u_ld6     i3  (IQ, D, clock_i, SN, RN, NOTIFY_REG);
   not       i4  (IQN, IQ);
   buf       i5  (Q, IQ);
   buf       i6  (QN, IQN);

   checkrs   i7  (c_SH_D, RN, SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLRSHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active transparent D-latch with set and reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLLRSHDX1 (D, GN, Q, QN, RN, SN);

   input     D, GN, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_RN, delay_SN, d_clock_i, IQN,
                   c_SH_D;

   not       i1  (d_clock_i, delay_GN);
   u_ld6     i3  (IQ, delay_D, d_clock_i, delay_SN, delay_RN, NOTIFY_REG);
   not       i4  (IQN, IQ);
   buf       i5  (Q, IQ);
   buf       i6  (QN, IQN);

   checkrs   i7  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_GN);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, c_SH_D;

   not       i1  (clock_i, GN);
   u_ld6     i3  (IQ, D, clock_i, SN, RN, NOTIFY_REG);
   not       i4  (IQN, IQ);
   buf       i5  (Q, IQ);
   buf       i6  (QN, IQN);

   checkrs   i7  (c_SH_D, RN, SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLRSHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active transparent D-latch with set and reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLLRSHDX2 (D, GN, Q, QN, RN, SN);

   input     D, GN, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_RN, delay_SN, d_clock_i, IQN,
                   c_SH_D;

   not       i1  (d_clock_i, delay_GN);
   u_ld6     i3  (IQ, delay_D, d_clock_i, delay_SN, delay_RN, NOTIFY_REG);
   not       i4  (IQN, IQ);
   buf       i5  (Q, IQ);
   buf       i6  (QN, IQN);

   checkrs   i7  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_GN);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, c_SH_D;

   not       i1  (clock_i, GN);
   u_ld6     i3  (IQ, D, clock_i, SN, RN, NOTIFY_REG);
   not       i4  (IQN, IQ);
   buf       i5  (Q, IQ);
   buf       i6  (QN, IQN);

   checkrs   i7  (c_SH_D, RN, SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLRSHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active transparent D-latch with set and reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLLRSHDX4 (D, GN, Q, QN, RN, SN);

   input     D, GN, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_RN, delay_SN, d_clock_i, IQN,
                   c_SH_D;

   not       i1  (d_clock_i, delay_GN);
   u_ld6     i3  (IQ, delay_D, d_clock_i, delay_SN, delay_RN, NOTIFY_REG);
   not       i4  (IQN, IQ);
   buf       i5  (Q, IQ);
   buf       i6  (QN, IQN);

   checkrs   i7  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_GN);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, c_SH_D;

   not       i1  (clock_i, GN);
   u_ld6     i3  (IQ, D, clock_i, SN, RN, NOTIFY_REG);
   not       i4  (IQN, IQ);
   buf       i5  (Q, IQ);
   buf       i6  (QN, IQN);

   checkrs   i7  (c_SH_D, RN, SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLRSQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active single Q transparent D-latch with set
//                      and reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLLRSQHDX0 (D, GN, Q, RN, SN);

   input     D, GN, RN, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_RN, delay_SN, d_clock_i, c_SH_D;

   not       i1  (d_clock_i, delay_GN);
   u_ld6     i3  (IQ, delay_D, d_clock_i, delay_SN, delay_RN, NOTIFY_REG);
   buf       i4  (Q, IQ);

   checkrs   i5  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_GN);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i1  (clock_i, GN);
   u_ld6     i3  (IQ, D, clock_i, SN, RN, NOTIFY_REG);
   buf       i4  (Q, IQ);

   checkrs   i5  (c_SH_D, RN, SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLRSQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active single Q transparent D-latch with set
//                      and reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLLRSQHDX1 (D, GN, Q, RN, SN);

   input     D, GN, RN, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_RN, delay_SN, d_clock_i, c_SH_D;

   not       i1  (d_clock_i, delay_GN);
   u_ld6     i3  (IQ, delay_D, d_clock_i, delay_SN, delay_RN, NOTIFY_REG);
   buf       i4  (Q, IQ);

   checkrs   i5  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_GN);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i1  (clock_i, GN);
   u_ld6     i3  (IQ, D, clock_i, SN, RN, NOTIFY_REG);
   buf       i4  (Q, IQ);

   checkrs   i5  (c_SH_D, RN, SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLRSQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active single Q transparent D-latch with set
//                      and reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLLRSQHDX2 (D, GN, Q, RN, SN);

   input     D, GN, RN, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_RN, delay_SN, d_clock_i, c_SH_D;

   not       i1  (d_clock_i, delay_GN);
   u_ld6     i3  (IQ, delay_D, d_clock_i, delay_SN, delay_RN, NOTIFY_REG);
   buf       i4  (Q, IQ);

   checkrs   i5  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_GN);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i1  (clock_i, GN);
   u_ld6     i3  (IQ, D, clock_i, SN, RN, NOTIFY_REG);
   buf       i4  (Q, IQ);

   checkrs   i5  (c_SH_D, RN, SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLRSQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active single Q transparent D-latch with set
//                      and reset
//   last modified by : XLICDD generated
//****************************************************************************

module DLLRSQHDX4 (D, GN, Q, RN, SN);

   input     D, GN, RN, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_RN, delay_SN, d_clock_i, c_SH_D;

   not       i1  (d_clock_i, delay_GN);
   u_ld6     i3  (IQ, delay_D, d_clock_i, delay_SN, delay_RN, NOTIFY_REG);
   buf       i4  (Q, IQ);

   checkrs   i5  (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_GN);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i1  (clock_i, GN);
   u_ld6     i3  (IQ, D, clock_i, SN, RN, NOTIFY_REG);
   buf       i4  (Q, IQ);

   checkrs   i5  (c_SH_D, RN, SN);

// timing section:
   specify

      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLRTHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active transparent D-latch with reset; tristate
//                      Q Buffer with active low enable
//   last modified by : XLICDD generated
//****************************************************************************

module DLLRTHDX1 (D, EN, GN, Q, RN);

   input     D, EN, GN, RN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_RN, d_clock_i, c_SH_D;

   not       i1  (d_clock_i, delay_GN);
   u_ld6     i2  (IQ, delay_D, d_clock_i, 1'b1, delay_RN, NOTIFY_REG);
   bufif0    i3  (Q, IQ, EN);

   checkrs   i4  (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i1  (clock_i, GN);
   u_ld6     i2  (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
   bufif0    i3  (Q, IQ, EN);

   checkrs   i4  (c_SH_D, RN, 1'b1);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLSHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active transparent D-latch with set
//   last modified by : XLICDD generated
//****************************************************************************

module DLLSHDX0 (D, GN, Q, QN, SN);

   input     D, GN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_SN, d_clock_i, IQN, c_SH_D;

   not       i0  (d_clock_i, delay_GN);
   u_ld6     i2  (IQ, delay_D, d_clock_i, delay_SN, 1'b1, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, c_SH_D;

   not       i0  (clock_i, GN);
   u_ld6     i2  (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLSHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active transparent D-latch with set
//   last modified by : XLICDD generated
//****************************************************************************

module DLLSHDX1 (D, GN, Q, QN, SN);

   input     D, GN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_SN, d_clock_i, IQN, c_SH_D;

   not       i0  (d_clock_i, delay_GN);
   u_ld6     i2  (IQ, delay_D, d_clock_i, delay_SN, 1'b1, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, c_SH_D;

   not       i0  (clock_i, GN);
   u_ld6     i2  (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLSHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active transparent D-latch with set
//   last modified by : XLICDD generated
//****************************************************************************

module DLLSHDX2 (D, GN, Q, QN, SN);

   input     D, GN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_SN, d_clock_i, IQN, c_SH_D;

   not       i0  (d_clock_i, delay_GN);
   u_ld6     i2  (IQ, delay_D, d_clock_i, delay_SN, 1'b1, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, c_SH_D;

   not       i0  (clock_i, GN);
   u_ld6     i2  (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLSHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active transparent D-latch with set
//   last modified by : XLICDD generated
//****************************************************************************

module DLLSHDX4 (D, GN, Q, QN, SN);

   input     D, GN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_SN, d_clock_i, IQN, c_SH_D;

   not       i0  (d_clock_i, delay_GN);
   u_ld6     i2  (IQ, delay_D, d_clock_i, delay_SN, 1'b1, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, IQN, c_SH_D;

   not       i0  (clock_i, GN);
   u_ld6     i2  (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
   not       i3  (IQN, IQ);
   buf       i4  (Q, IQ);
   buf       i5  (QN, IQN);

   checkrs   i6  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      (negedge GN => (QN -: QN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLSQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active single Q transparent D-latch with set
//   last modified by : XLICDD generated
//****************************************************************************

module DLLSQHDX0 (D, GN, Q, SN);

   input     D, GN, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_SN, d_clock_i, c_SH_D;

   not       i0  (d_clock_i, delay_GN);
   u_ld6     i2  (IQ, delay_D, d_clock_i, delay_SN, 1'b1, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i0  (clock_i, GN);
   u_ld6     i2  (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLSQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active single Q transparent D-latch with set
//   last modified by : XLICDD generated
//****************************************************************************

module DLLSQHDX1 (D, GN, Q, SN);

   input     D, GN, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_SN, d_clock_i, c_SH_D;

   not       i0  (d_clock_i, delay_GN);
   u_ld6     i2  (IQ, delay_D, d_clock_i, delay_SN, 1'b1, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i0  (clock_i, GN);
   u_ld6     i2  (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLSQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active single Q transparent D-latch with set
//   last modified by : XLICDD generated
//****************************************************************************

module DLLSQHDX2 (D, GN, Q, SN);

   input     D, GN, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_SN, d_clock_i, c_SH_D;

   not       i0  (d_clock_i, delay_GN);
   u_ld6     i2  (IQ, delay_D, d_clock_i, delay_SN, 1'b1, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i0  (clock_i, GN);
   u_ld6     i2  (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLSQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active single Q transparent D-latch with set
//   last modified by : XLICDD generated
//****************************************************************************

module DLLSQHDX4 (D, GN, Q, SN);

   input     D, GN, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_SN, d_clock_i, c_SH_D;

   not       i0  (d_clock_i, delay_GN);
   u_ld6     i2  (IQ, delay_D, d_clock_i, delay_SN, 1'b1, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i0  (clock_i, GN);
   u_ld6     i2  (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
   buf       i3  (Q, IQ);

   checkrs   i4  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLSTHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active transparent D-latch with set; tristate Q
//                      Buffer with active low enable
//   last modified by : XLICDD generated
//****************************************************************************

module DLLSTHDX1 (D, EN, GN, Q, SN);

   input     D, EN, GN, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, delay_SN, d_clock_i, c_SH_D;

   not       i0  (d_clock_i, delay_GN);
   u_ld6     i2  (IQ, delay_D, d_clock_i, delay_SN, 1'b1, NOTIFY_REG);
   bufif0    i3  (Q, IQ, EN);

   checkrs   i4  (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_GN, delay_D);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_GN);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, c_SH_D;

   not       i0  (clock_i, GN);
   u_ld6     i2  (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
   bufif0    i3  (Q, IQ, EN);

   checkrs   i4  (c_SH_D, 1'b1, SN);

// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

      $setuphold (posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLLTHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : low active transparent D-latch; tristate Q Buffer
//                      with active low enable
//   last modified by : XLICDD generated
//****************************************************************************

module DLLTHDX1 (D, EN, GN, Q);

   input     D, EN, GN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_GN, delay_D, d_clock_i;

   not       i0  (d_clock_i, delay_GN);
   u_ld6     i1  (IQ, delay_D, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   bufif0    i2  (Q, IQ, EN);


// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

      $setuphold (posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN,
                   delay_D);
      $setuphold (posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN,
                   delay_D);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i;

   not       i0  (clock_i, GN);
   u_ld6     i1  (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   bufif0    i2  (Q, IQ, EN);


// timing section:
   specify

      (negedge GN => (Q -: Q)) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

      $setuphold (posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);

      $width (negedge GN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//*****************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLY1HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Delay Cell 1ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLICDD generated
//*****************************************************************

module DLY1HDX0 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);



// timing section:
   specify

      (A +=> Q) = (0.82, 0.67);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//*****************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLY1HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Delay Cell 1ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLICDD generated
//*****************************************************************

module DLY1HDX1 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);



// timing section:
   specify

      (A +=> Q) = (0.86, 0.79);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//*****************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLY2HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Delay Cell 2ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLICDD generated
//*****************************************************************

module DLY2HDX0 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);



// timing section:
   specify

      (A +=> Q) = (1.79, 1.51);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//*****************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLY2HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Delay Cell 2ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLICDD generated
//*****************************************************************

module DLY2HDX1 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);



// timing section:
   specify

      (A +=> Q) = (1.86, 1.76);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//*****************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLY4HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Delay Cell 4ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLICDD generated
//*****************************************************************

module DLY4HDX0 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);



// timing section:
   specify

      (A +=> Q) = (3.29, 3.07);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//*****************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLY4HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Delay Cell 4ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLICDD generated
//*****************************************************************

module DLY4HDX1 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);



// timing section:
   specify

      (A +=> Q) = (3.42, 3.53);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//*****************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLY8HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Delay Cell 8ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLICDD generated
//*****************************************************************

module DLY8HDX0 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);



// timing section:
   specify

      (A +=> Q) = (6.97, 7.33);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//*****************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DLY8HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Delay Cell 8ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLICDD generated
//*****************************************************************

module DLY8HDX1 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);



// timing section:
   specify

      (A +=> Q) = (7.10, 7.69);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : EN2HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input XNOR
//   last modified by : XLICDD generated
//****************************************************************************

module EN2HDX0 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: !(A^B)
   xnor      i0  (Q, A, B);

// timing section:
   specify

      (posedge A => (Q +: Q)) = (0.02, 0.02);
      (negedge A => (Q +: Q)) = (0.02, 0.02);
         if ((B == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (posedge B => (Q +: Q)) = (0.02, 0.02);
      (negedge B => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b1)) (B +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : EN2HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input XNOR
//   last modified by : XLICDD generated
//****************************************************************************

module EN2HDX1 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: !(A^B)
   xnor      i0  (Q, A, B);

// timing section:
   specify

      (posedge A => (Q +: Q)) = (0.02, 0.02);
      (negedge A => (Q +: Q)) = (0.02, 0.02);
         if ((B == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (posedge B => (Q +: Q)) = (0.02, 0.02);
      (negedge B => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b1)) (B +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : EN2HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input XNOR
//   last modified by : XLICDD generated
//****************************************************************************

module EN2HDX2 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: !(A^B)
   xnor      i0  (Q, A, B);

// timing section:
   specify

      (posedge A => (Q +: Q)) = (0.02, 0.02);
      (negedge A => (Q +: Q)) = (0.02, 0.02);
         if ((B == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (posedge B => (Q +: Q)) = (0.02, 0.02);
      (negedge B => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b1)) (B +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : EN2HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input XNOR
//   last modified by : XLICDD generated
//****************************************************************************

module EN2HDX4 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: !(A^B)
   xnor      i0  (Q, A, B);

// timing section:
   specify

      (posedge A => (Q +: Q)) = (0.02, 0.02);
      (negedge A => (Q +: Q)) = (0.02, 0.02);
         if ((B == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (posedge B => (Q +: Q)) = (0.02, 0.02);
      (negedge B => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b1)) (B +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : EN3HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input XNOR
//   last modified by : XLICDD generated
//****************************************************************************

module EN3HDX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !(A^B^C)
   xnor      i0  (Q, A, B, C);

// timing section:
   specify

      (posedge A => (Q +: Q)) = (0.02, 0.02);
      (negedge A => (Q +: Q)) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A +=> Q) =
                   (0.02, 0.02);
      (posedge B => (Q +: Q)) = (0.02, 0.02);
      (negedge B => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b0)) (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (posedge C => (Q +: Q)) = (0.02, 0.02);
      (negedge C => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : EN3HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input XNOR
//   last modified by : XLICDD generated
//****************************************************************************

module EN3HDX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !(A^B^C)
   xnor      i0  (Q, A, B, C);

// timing section:
   specify

      (posedge A => (Q +: Q)) = (0.02, 0.02);
      (negedge A => (Q +: Q)) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A +=> Q) =
                   (0.02, 0.02);
      (posedge B => (Q +: Q)) = (0.02, 0.02);
      (negedge B => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b0)) (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (posedge C => (Q +: Q)) = (0.02, 0.02);
      (negedge C => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : EN3HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input XNOR
//   last modified by : XLICDD generated
//****************************************************************************

module EN3HDX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !(A^B^C)
   xnor      i0  (Q, A, B, C);

// timing section:
   specify

      (posedge A => (Q +: Q)) = (0.02, 0.02);
      (negedge A => (Q +: Q)) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A +=> Q) =
                   (0.02, 0.02);
      (posedge B => (Q +: Q)) = (0.02, 0.02);
      (negedge B => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b0)) (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (posedge C => (Q +: Q)) = (0.02, 0.02);
      (negedge C => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : EN3HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input XNOR
//   last modified by : XLICDD generated
//****************************************************************************

module EN3HDX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !(A^B^C)
   xnor      i0  (Q, A, B, C);

// timing section:
   specify

      (posedge A => (Q +: Q)) = (0.02, 0.02);
      (negedge A => (Q +: Q)) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A +=> Q) =
                   (0.02, 0.02);
      (posedge B => (Q +: Q)) = (0.02, 0.02);
      (negedge B => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b0)) (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (posedge C => (Q +: Q)) = (0.02, 0.02);
      (negedge C => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : EO2HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input XOR
//   last modified by : XLICDD generated
//****************************************************************************

module EO2HDX0 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: (A^B)
   xor       i0  (Q, A, B);

// timing section:
   specify

      (posedge A => (Q +: Q)) = (0.02, 0.02);
      (negedge A => (Q +: Q)) = (0.02, 0.02);
         if ((B == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (posedge B => (Q +: Q)) = (0.02, 0.02);
      (negedge B => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b1)) (B -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : EO2HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input XOR
//   last modified by : XLICDD generated
//****************************************************************************

module EO2HDX1 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: (A^B)
   xor       i0  (Q, A, B);

// timing section:
   specify

      (posedge A => (Q +: Q)) = (0.02, 0.02);
      (negedge A => (Q +: Q)) = (0.02, 0.02);
         if ((B == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (posedge B => (Q +: Q)) = (0.02, 0.02);
      (negedge B => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b1)) (B -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : EO2HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input XOR
//   last modified by : XLICDD generated
//****************************************************************************

module EO2HDX2 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: (A^B)
   xor       i0  (Q, A, B);

// timing section:
   specify

      (posedge A => (Q +: Q)) = (0.02, 0.02);
      (negedge A => (Q +: Q)) = (0.02, 0.02);
         if ((B == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (posedge B => (Q +: Q)) = (0.02, 0.02);
      (negedge B => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b1)) (B -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : EO2HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input XOR
//   last modified by : XLICDD generated
//****************************************************************************

module EO2HDX4 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: (A^B)
   xor       i0  (Q, A, B);

// timing section:
   specify

      (posedge A => (Q +: Q)) = (0.02, 0.02);
      (negedge A => (Q +: Q)) = (0.02, 0.02);
         if ((B == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (posedge B => (Q +: Q)) = (0.02, 0.02);
      (negedge B => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b1)) (B -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : EO3HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input XOR
//   last modified by : XLICDD generated
//****************************************************************************

module EO3HDX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: (A^B^C)
   xor       i0  (Q, A, B, C);

// timing section:
   specify

      (posedge A => (Q +: Q)) = (0.02, 0.02);
      (negedge A => (Q +: Q)) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A -=> Q) =
                   (0.02, 0.02);
      (posedge B => (Q +: Q)) = (0.02, 0.02);
      (negedge B => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b0)) (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (posedge C => (Q +: Q)) = (0.02, 0.02);
      (negedge C => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : EO3HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input XOR
//   last modified by : XLICDD generated
//****************************************************************************

module EO3HDX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: (A^B^C)
   xor       i0  (Q, A, B, C);

// timing section:
   specify

      (posedge A => (Q +: Q)) = (0.02, 0.02);
      (negedge A => (Q +: Q)) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A -=> Q) =
                   (0.02, 0.02);
      (posedge B => (Q +: Q)) = (0.02, 0.02);
      (negedge B => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b0)) (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (posedge C => (Q +: Q)) = (0.02, 0.02);
      (negedge C => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : EO3HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input XOR
//   last modified by : XLICDD generated
//****************************************************************************

module EO3HDX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: (A^B^C)
   xor       i0  (Q, A, B, C);

// timing section:
   specify

      (posedge A => (Q +: Q)) = (0.02, 0.02);
      (negedge A => (Q +: Q)) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A -=> Q) =
                   (0.02, 0.02);
      (posedge B => (Q +: Q)) = (0.02, 0.02);
      (negedge B => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b0)) (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (posedge C => (Q +: Q)) = (0.02, 0.02);
      (negedge C => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : EO3HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input XOR
//   last modified by : XLICDD generated
//****************************************************************************

module EO3HDX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: (A^B^C)
   xor       i0  (Q, A, B, C);

// timing section:
   specify

      (posedge A => (Q +: Q)) = (0.02, 0.02);
      (negedge A => (Q +: Q)) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A -=> Q) =
                   (0.02, 0.02);
      (posedge B => (Q +: Q)) = (0.02, 0.02);
      (negedge B => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b0)) (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (posedge C => (Q +: Q)) = (0.02, 0.02);
      (negedge C => (Q +: Q)) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FAHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Full Adder
//   last modified by : XLICDD generated
//****************************************************************************

module FAHDX0 (A, B, CI, CO, S);

   input     A, B, CI;
   output    CO, S;

// Function CO: (B*CI) + (A*CI) + (A*B)
   and       i0  (n_0, B, CI);
   and       i1  (n_1, A, CI);
   and       i2  (n_2, A, B);
   or        i3  (CO, n_0, n_1, n_2);

// Function S: (A^B^CI)
   xor       i4  (S, A, B, CI);

// timing section:
   specify

      (A +=> CO) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);

      (posedge A => (S +: S)) = (0.02, 0.02);
      (negedge A => (S +: S)) = (0.02, 0.02);
         if (((B == 1'b0 && CI == 1'b0))) (A +=> S) = (0.02, 0.02);
         if ((B == 1'b1 && CI == 1'b0)) (A -=> S) = (0.02, 0.02);
         if (((B == 1'b1 && CI == 1'b1))) (A +=> S) = (0.02, 0.02);
      (posedge B => (S +: S)) = (0.02, 0.02);
      (negedge B => (S +: S)) = (0.02, 0.02);
         if ((A == 1'b0 && CI == 1'b0)) (B +=> S) = (0.02, 0.02);
         if ((A == 1'b1 && CI == 1'b0)) (B -=> S) = (0.02, 0.02);
         if ((A == 1'b1 && CI == 1'b1)) (B +=> S) = (0.02, 0.02);
      (posedge CI => (S +: S)) = (0.02, 0.02);
      (negedge CI => (S +: S)) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0)) (CI +=> S) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (CI -=> S) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1)) (CI +=> S) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FAHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Full Adder
//   last modified by : XLICDD generated
//****************************************************************************

module FAHDX1 (A, B, CI, CO, S);

   input     A, B, CI;
   output    CO, S;

// Function CO: (B*CI) + (A*CI) + (A*B)
   and       i0  (n_0, B, CI);
   and       i1  (n_1, A, CI);
   and       i2  (n_2, A, B);
   or        i3  (CO, n_0, n_1, n_2);

// Function S: (A^B^CI)
   xor       i4  (S, A, B, CI);

// timing section:
   specify

      (A +=> CO) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);

      (posedge A => (S +: S)) = (0.02, 0.02);
      (negedge A => (S +: S)) = (0.02, 0.02);
         if (((B == 1'b0 && CI == 1'b0))) (A +=> S) = (0.02, 0.02);
         if ((B == 1'b1 && CI == 1'b0)) (A -=> S) = (0.02, 0.02);
         if (((B == 1'b1 && CI == 1'b1))) (A +=> S) = (0.02, 0.02);
      (posedge B => (S +: S)) = (0.02, 0.02);
      (negedge B => (S +: S)) = (0.02, 0.02);
         if ((A == 1'b0 && CI == 1'b0)) (B +=> S) = (0.02, 0.02);
         if ((A == 1'b1 && CI == 1'b0)) (B -=> S) = (0.02, 0.02);
         if ((A == 1'b1 && CI == 1'b1)) (B +=> S) = (0.02, 0.02);
      (posedge CI => (S +: S)) = (0.02, 0.02);
      (negedge CI => (S +: S)) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0)) (CI +=> S) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (CI -=> S) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1)) (CI +=> S) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FAHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Full Adder
//   last modified by : XLICDD generated
//****************************************************************************

module FAHDX2 (A, B, CI, CO, S);

   input     A, B, CI;
   output    CO, S;

// Function CO: (B*CI) + (A*CI) + (A*B)
   and       i0  (n_0, B, CI);
   and       i1  (n_1, A, CI);
   and       i2  (n_2, A, B);
   or        i3  (CO, n_0, n_1, n_2);

// Function S: (A^B^CI)
   xor       i4  (S, A, B, CI);

// timing section:
   specify

      (A +=> CO) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);

      (posedge A => (S +: S)) = (0.02, 0.02);
      (negedge A => (S +: S)) = (0.02, 0.02);
         if (((B == 1'b0 && CI == 1'b0))) (A +=> S) = (0.02, 0.02);
         if ((B == 1'b1 && CI == 1'b0)) (A -=> S) = (0.02, 0.02);
         if (((B == 1'b1 && CI == 1'b1))) (A +=> S) = (0.02, 0.02);
      (posedge B => (S +: S)) = (0.02, 0.02);
      (negedge B => (S +: S)) = (0.02, 0.02);
         if ((A == 1'b0 && CI == 1'b0)) (B +=> S) = (0.02, 0.02);
         if ((A == 1'b1 && CI == 1'b0)) (B -=> S) = (0.02, 0.02);
         if ((A == 1'b1 && CI == 1'b1)) (B +=> S) = (0.02, 0.02);
      (posedge CI => (S +: S)) = (0.02, 0.02);
      (negedge CI => (S +: S)) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0)) (CI +=> S) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (CI -=> S) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1)) (CI +=> S) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FAHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Full Adder
//   last modified by : XLICDD generated
//****************************************************************************

module FAHDX4 (A, B, CI, CO, S);

   input     A, B, CI;
   output    CO, S;

// Function CO: (B*CI) + (A*CI) + (A*B)
   and       i0  (n_0, B, CI);
   and       i1  (n_1, A, CI);
   and       i2  (n_2, A, B);
   or        i3  (CO, n_0, n_1, n_2);

// Function S: (A^B^CI)
   xor       i4  (S, A, B, CI);

// timing section:
   specify

      (A +=> CO) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);

      (posedge A => (S +: S)) = (0.02, 0.02);
      (negedge A => (S +: S)) = (0.02, 0.02);
         if (((B == 1'b0 && CI == 1'b0))) (A +=> S) = (0.02, 0.02);
         if ((B == 1'b1 && CI == 1'b0)) (A -=> S) = (0.02, 0.02);
         if (((B == 1'b1 && CI == 1'b1))) (A +=> S) = (0.02, 0.02);
      (posedge B => (S +: S)) = (0.02, 0.02);
      (negedge B => (S +: S)) = (0.02, 0.02);
         if ((A == 1'b0 && CI == 1'b0)) (B +=> S) = (0.02, 0.02);
         if ((A == 1'b1 && CI == 1'b0)) (B -=> S) = (0.02, 0.02);
         if ((A == 1'b1 && CI == 1'b1)) (B +=> S) = (0.02, 0.02);
      (posedge CI => (S +: S)) = (0.02, 0.02);
      (negedge CI => (S +: S)) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0)) (CI +=> S) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (CI -=> S) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b1)) (CI +=> S) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : HAHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Half Adder
//   last modified by : XLICDD generated
//****************************************************************************

module HAHDX0 (A, B, CO, S);

   input     A, B;
   output    CO, S;

// Function CO: (A*B)
   and       i0  (CO, A, B);

// Function S: (A^B)
   xor       i1  (S, A, B);

// timing section:
   specify

      (A +=> CO) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);

      (posedge A => (S +: S)) = (0.02, 0.02);
      (negedge A => (S +: S)) = (0.02, 0.02);
         if ((B == 1'b0)) (A +=> S) = (0.02, 0.02);
      (posedge B => (S +: S)) = (0.02, 0.02);
      (negedge B => (S +: S)) = (0.02, 0.02);
         if ((A == 1'b0)) (B +=> S) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : HAHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Half Adder
//   last modified by : XLICDD generated
//****************************************************************************

module HAHDX1 (A, B, CO, S);

   input     A, B;
   output    CO, S;

// Function CO: (A*B)
   and       i0  (CO, A, B);

// Function S: (A^B)
   xor       i1  (S, A, B);

// timing section:
   specify

      (A +=> CO) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);

      (posedge A => (S +: S)) = (0.02, 0.02);
      (negedge A => (S +: S)) = (0.02, 0.02);
         if ((B == 1'b0)) (A +=> S) = (0.02, 0.02);
      (posedge B => (S +: S)) = (0.02, 0.02);
      (negedge B => (S +: S)) = (0.02, 0.02);
         if ((A == 1'b0)) (B +=> S) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : HAHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Half Adder
//   last modified by : XLICDD generated
//****************************************************************************

module HAHDX2 (A, B, CO, S);

   input     A, B;
   output    CO, S;

// Function CO: (A*B)
   and       i0  (CO, A, B);

// Function S: (A^B)
   xor       i1  (S, A, B);

// timing section:
   specify

      (A +=> CO) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);

      (posedge A => (S +: S)) = (0.02, 0.02);
      (negedge A => (S +: S)) = (0.02, 0.02);
         if ((B == 1'b0)) (A +=> S) = (0.02, 0.02);
      (posedge B => (S +: S)) = (0.02, 0.02);
      (negedge B => (S +: S)) = (0.02, 0.02);
         if ((A == 1'b0)) (B +=> S) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : HAHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Half Adder
//   last modified by : XLICDD generated
//****************************************************************************

module HAHDX4 (A, B, CO, S);

   input     A, B;
   output    CO, S;

// Function CO: (A*B)
   and       i0  (CO, A, B);

// Function S: (A^B)
   xor       i1  (S, A, B);

// timing section:
   specify

      (A +=> CO) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);

      (posedge A => (S +: S)) = (0.02, 0.02);
      (negedge A => (S +: S)) = (0.02, 0.02);
         if ((B == 1'b0)) (A +=> S) = (0.02, 0.02);
      (posedge B => (S +: S)) = (0.02, 0.02);
      (negedge B => (S +: S)) = (0.02, 0.02);
         if ((A == 1'b0)) (B +=> S) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : INHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Inverter
//   last modified by : XLICDD generated
//****************************************************************************

module INHDX0 (A, Q);

   input     A;
   output    Q;

// Function Q: !(A)
   not       i0  (Q, A);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : INHDX12
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Inverter
//   last modified by : XLICDD generated
//****************************************************************************

module INHDX12 (A, Q);

   input     A;
   output    Q;

// Function Q: !(A)
   not       i0  (Q, A);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : INHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Inverter
//   last modified by : XLICDD generated
//****************************************************************************

module INHDX1 (A, Q);

   input     A;
   output    Q;

// Function Q: !(A)
   not       i0  (Q, A);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : INHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Inverter
//   last modified by : XLICDD generated
//****************************************************************************

module INHDX2 (A, Q);

   input     A;
   output    Q;

// Function Q: !(A)
   not       i0  (Q, A);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : INHDX3
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Inverter
//   last modified by : XLICDD generated
//****************************************************************************

module INHDX3 (A, Q);

   input     A;
   output    Q;

// Function Q: !(A)
   not       i0  (Q, A);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : INHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Inverter
//   last modified by : XLICDD generated
//****************************************************************************

module INHDX4 (A, Q);

   input     A;
   output    Q;

// Function Q: !(A)
   not       i0  (Q, A);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : INHDX6
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Inverter
//   last modified by : XLICDD generated
//****************************************************************************

module INHDX6 (A, Q);

   input     A;
   output    Q;

// Function Q: !(A)
   not       i0  (Q, A);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : INHDX8
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Inverter
//   last modified by : XLICDD generated
//****************************************************************************

module INHDX8 (A, Q);

   input     A;
   output    Q;

// Function Q: !(A)
   not       i0  (Q, A);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ITHHDX12
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Inverter with active high Enable
//   last modified by : XLICDD generated
//****************************************************************************

module ITHHDX12 (A, E, Q);

   input     A, E;
   output    Q;

// Function Q: !(A); Tristate function: !E
   not       i0  (n_0, A);
   bufif1    i2  (Q, n_0, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (E  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ITHHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Inverter with active high Enable
//   last modified by : XLICDD generated
//****************************************************************************

module ITHHDX1 (A, E, Q);

   input     A, E;
   output    Q;

// Function Q: !(A); Tristate function: !E
   not       i0  (n_0, A);
   bufif1    i2  (Q, n_0, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (E  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ITHHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Inverter with active high Enable
//   last modified by : XLICDD generated
//****************************************************************************

module ITHHDX2 (A, E, Q);

   input     A, E;
   output    Q;

// Function Q: !(A); Tristate function: !E
   not       i0  (n_0, A);
   bufif1    i2  (Q, n_0, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (E  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ITHHDX3
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Inverter with active high Enable
//   last modified by : XLICDD generated
//****************************************************************************

module ITHHDX3 (A, E, Q);

   input     A, E;
   output    Q;

// Function Q: !(A); Tristate function: !E
   not       i0  (n_0, A);
   bufif1    i2  (Q, n_0, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (E  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ITHHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Inverter with active high Enable
//   last modified by : XLICDD generated
//****************************************************************************

module ITHHDX4 (A, E, Q);

   input     A, E;
   output    Q;

// Function Q: !(A); Tristate function: !E
   not       i0  (n_0, A);
   bufif1    i2  (Q, n_0, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (E  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ITHHDX6
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Inverter with active high Enable
//   last modified by : XLICDD generated
//****************************************************************************

module ITHHDX6 (A, E, Q);

   input     A, E;
   output    Q;

// Function Q: !(A); Tristate function: !E
   not       i0  (n_0, A);
   bufif1    i2  (Q, n_0, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (E  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ITHHDX8
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Inverter with active high Enable
//   last modified by : XLICDD generated
//****************************************************************************

module ITHHDX8 (A, E, Q);

   input     A, E;
   output    Q;

// Function Q: !(A); Tristate function: !E
   not       i0  (n_0, A);
   bufif1    i2  (Q, n_0, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (E  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ITLHDX12
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Inverter with active low Enable
//   last modified by : XLICDD generated
//****************************************************************************

module ITLHDX12 (A, EN, Q);

   input     A, EN;
   output    Q;

// Function Q: !(A); Tristate function: EN
   not       i0  (n_0, A);
   bufif0    i1  (Q, n_0, EN);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ITLHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Inverter with active low Enable
//   last modified by : XLICDD generated
//****************************************************************************

module ITLHDX1 (A, EN, Q);

   input     A, EN;
   output    Q;

// Function Q: !(A); Tristate function: EN
   not       i0  (n_0, A);
   bufif0    i1  (Q, n_0, EN);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ITLHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Inverter with active low Enable
//   last modified by : XLICDD generated
//****************************************************************************

module ITLHDX2 (A, EN, Q);

   input     A, EN;
   output    Q;

// Function Q: !(A); Tristate function: EN
   not       i0  (n_0, A);
   bufif0    i1  (Q, n_0, EN);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ITLHDX3
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Inverter with active low Enable
//   last modified by : XLICDD generated
//****************************************************************************

module ITLHDX3 (A, EN, Q);

   input     A, EN;
   output    Q;

// Function Q: !(A); Tristate function: EN
   not       i0  (n_0, A);
   bufif0    i1  (Q, n_0, EN);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ITLHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Inverter with active low Enable
//   last modified by : XLICDD generated
//****************************************************************************

module ITLHDX4 (A, EN, Q);

   input     A, EN;
   output    Q;

// Function Q: !(A); Tristate function: EN
   not       i0  (n_0, A);
   bufif0    i1  (Q, n_0, EN);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ITLHDX6
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Inverter with active low Enable
//   last modified by : XLICDD generated
//****************************************************************************

module ITLHDX6 (A, EN, Q);

   input     A, EN;
   output    Q;

// Function Q: !(A); Tristate function: EN
   not       i0  (n_0, A);
   bufif0    i1  (Q, n_0, EN);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ITLHDX8
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Tristate Inverter with active low Enable
//   last modified by : XLICDD generated
//****************************************************************************

module ITLHDX8 (A, EN, Q);

   input     A, EN;
   output    Q;

// Function Q: !(A); Tristate function: EN
   not       i0  (n_0, A);
   bufif0    i1  (Q, n_0, EN);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (EN  => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LGCNHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge clock gating cell, high latch Enable
//   last modified by : XLICDD generated
//****************************************************************************

module LGCNHDX0 (CLK, E, GCLK);

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E;

   u_ld1     i0  (IQ, delay_E, delay_CLK, NOTIFY_REG);
   not       i1  (n_0, IQ);
   or        i2  (GCLK, delay_CLK, n_0);


// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);
      $setuphold (negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ;

   u_ld1     i0  (IQ, E, CLK, NOTIFY_REG);
   not       i1  (n_0, IQ);
   or        i2  (GCLK, CLK, n_0);


// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LGCNHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge clock gating cell, high latch Enable
//   last modified by : XLICDD generated
//****************************************************************************

module LGCNHDX1 (CLK, E, GCLK);

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E;

   u_ld1     i0  (IQ, delay_E, delay_CLK, NOTIFY_REG);
   not       i1  (n_0, IQ);
   or        i2  (GCLK, delay_CLK, n_0);


// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);
      $setuphold (negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ;

   u_ld1     i0  (IQ, E, CLK, NOTIFY_REG);
   not       i1  (n_0, IQ);
   or        i2  (GCLK, CLK, n_0);


// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LGCNHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge clock gating cell, high latch Enable
//   last modified by : XLICDD generated
//****************************************************************************

module LGCNHDX2 (CLK, E, GCLK);

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E;

   u_ld1     i0  (IQ, delay_E, delay_CLK, NOTIFY_REG);
   not       i1  (n_0, IQ);
   or        i2  (GCLK, delay_CLK, n_0);


// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);
      $setuphold (negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ;

   u_ld1     i0  (IQ, E, CLK, NOTIFY_REG);
   not       i1  (n_0, IQ);
   or        i2  (GCLK, CLK, n_0);


// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LGCNHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge clock gating cell, high latch Enable
//   last modified by : XLICDD generated
//****************************************************************************

module LGCNHDX4 (CLK, E, GCLK);

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E;

   u_ld1     i0  (IQ, delay_E, delay_CLK, NOTIFY_REG);
   not       i1  (n_0, IQ);
   or        i2  (GCLK, delay_CLK, n_0);


// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);
      $setuphold (negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ;

   u_ld1     i0  (IQ, E, CLK, NOTIFY_REG);
   not       i1  (n_0, IQ);
   or        i2  (GCLK, CLK, n_0);


// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LGCPHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge clock gating cell, low latch Enable
//   last modified by : XLICDD generated
//****************************************************************************

module LGCPHDX0 (CLK, E, GCLK);

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E, d_clock_i;

   not       i0  (d_clock_i, delay_CLK);
   u_ld1     i1  (IQ, delay_E, d_clock_i, NOTIFY_REG);
   and       i2  (GCLK, delay_CLK, IQ);


// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);
      $setuphold (posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i;

   not       i0  (clock_i, CLK);
   u_ld1     i1  (IQ, E, clock_i, NOTIFY_REG);
   and       i2  (GCLK, CLK, IQ);


// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LGCPHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge clock gating cell, low latch Enable
//   last modified by : XLICDD generated
//****************************************************************************

module LGCPHDX1 (CLK, E, GCLK);

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E, d_clock_i;

   not       i0  (d_clock_i, delay_CLK);
   u_ld1     i1  (IQ, delay_E, d_clock_i, NOTIFY_REG);
   and       i2  (GCLK, delay_CLK, IQ);


// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);
      $setuphold (posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i;

   not       i0  (clock_i, CLK);
   u_ld1     i1  (IQ, E, clock_i, NOTIFY_REG);
   and       i2  (GCLK, CLK, IQ);


// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LGCPHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge clock gating cell, low latch Enable
//   last modified by : XLICDD generated
//****************************************************************************

module LGCPHDX2 (CLK, E, GCLK);

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E, d_clock_i;

   not       i0  (d_clock_i, delay_CLK);
   u_ld1     i1  (IQ, delay_E, d_clock_i, NOTIFY_REG);
   and       i2  (GCLK, delay_CLK, IQ);


// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);
      $setuphold (posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i;

   not       i0  (clock_i, CLK);
   u_ld1     i1  (IQ, E, clock_i, NOTIFY_REG);
   and       i2  (GCLK, CLK, IQ);


// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LGCPHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge clock gating cell, low latch Enable
//   last modified by : XLICDD generated
//****************************************************************************

module LGCPHDX4 (CLK, E, GCLK);

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E, d_clock_i;

   not       i0  (d_clock_i, delay_CLK);
   u_ld1     i1  (IQ, delay_E, d_clock_i, NOTIFY_REG);
   and       i2  (GCLK, delay_CLK, IQ);


// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);
      $setuphold (posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i;

   not       i0  (clock_i, CLK);
   u_ld1     i1  (IQ, E, clock_i, NOTIFY_REG);
   and       i2  (GCLK, CLK, IQ);


// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LSGCNHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge clock gating cell, high latch Enable, scan
//                      precontrol
//   last modified by : XLICDD generated
//****************************************************************************

module LSGCNHDX0 (CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E, delay_SE, d_dat_i, c_SH_E, c_SH_SE,
                   c_SH_E_v, c_SH_SE_v;

   or        i0  (d_dat_i, delay_E, delay_SE);
   u_ld1     i1  (IQ, d_dat_i, delay_CLK, NOTIFY_REG);
   not       i2  (n_0, IQ);
   or        i3  (GCLK, delay_CLK, n_0);

   not       i4  (c_SH_E, delay_SE);
   not       i5  (c_SH_SE, delay_E);
   not #(0.01) i6  (c_SH_E_v, delay_SE);
   not #(0.01) i7  (c_SH_SE_v, delay_E);

// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_E);
      $setuphold (negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CLK, delay_E);

      $setuphold (negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_SE);
      $setuphold (negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_SE);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

   or        i0  (dat_i, E, SE);
   u_ld1     i1  (IQ, dat_i, CLK, NOTIFY_REG);
   not       i2  (n_0, IQ);
   or        i3  (GCLK, CLK, n_0);

   not       i4  (c_SH_E, SE);
   not       i5  (c_SH_SE, E);
   not #(0.01) i6  (c_SH_E_v, SE);
   not #(0.01) i7  (c_SH_SE_v, E);

// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02,
                   NOTIFY_REG);
      $setuphold (negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02,
                   NOTIFY_REG);
      $setuphold (negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02,
                   NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LSGCNHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge clock gating cell, high latch Enable, scan
//                      precontrol
//   last modified by : XLICDD generated
//****************************************************************************

module LSGCNHDX1 (CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E, delay_SE, d_dat_i, c_SH_E, c_SH_SE,
                   c_SH_E_v, c_SH_SE_v;

   or        i0  (d_dat_i, delay_E, delay_SE);
   u_ld1     i1  (IQ, d_dat_i, delay_CLK, NOTIFY_REG);
   not       i2  (n_0, IQ);
   or        i3  (GCLK, delay_CLK, n_0);

   not       i4  (c_SH_E, delay_SE);
   not       i5  (c_SH_SE, delay_E);
   not #(0.01) i6  (c_SH_E_v, delay_SE);
   not #(0.01) i7  (c_SH_SE_v, delay_E);

// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_E);
      $setuphold (negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CLK, delay_E);

      $setuphold (negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_SE);
      $setuphold (negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_SE);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

   or        i0  (dat_i, E, SE);
   u_ld1     i1  (IQ, dat_i, CLK, NOTIFY_REG);
   not       i2  (n_0, IQ);
   or        i3  (GCLK, CLK, n_0);

   not       i4  (c_SH_E, SE);
   not       i5  (c_SH_SE, E);
   not #(0.01) i6  (c_SH_E_v, SE);
   not #(0.01) i7  (c_SH_SE_v, E);

// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02,
                   NOTIFY_REG);
      $setuphold (negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02,
                   NOTIFY_REG);
      $setuphold (negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02,
                   NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LSGCNHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge clock gating cell, high latch Enable, scan
//                      precontrol
//   last modified by : XLICDD generated
//****************************************************************************

module LSGCNHDX2 (CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E, delay_SE, d_dat_i, c_SH_E, c_SH_SE,
                   c_SH_E_v, c_SH_SE_v;

   or        i0  (d_dat_i, delay_E, delay_SE);
   u_ld1     i1  (IQ, d_dat_i, delay_CLK, NOTIFY_REG);
   not       i2  (n_0, IQ);
   or        i3  (GCLK, delay_CLK, n_0);

   not       i4  (c_SH_E, delay_SE);
   not       i5  (c_SH_SE, delay_E);
   not #(0.01) i6  (c_SH_E_v, delay_SE);
   not #(0.01) i7  (c_SH_SE_v, delay_E);

// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_E);
      $setuphold (negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CLK, delay_E);

      $setuphold (negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_SE);
      $setuphold (negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_SE);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

   or        i0  (dat_i, E, SE);
   u_ld1     i1  (IQ, dat_i, CLK, NOTIFY_REG);
   not       i2  (n_0, IQ);
   or        i3  (GCLK, CLK, n_0);

   not       i4  (c_SH_E, SE);
   not       i5  (c_SH_SE, E);
   not #(0.01) i6  (c_SH_E_v, SE);
   not #(0.01) i7  (c_SH_SE_v, E);

// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02,
                   NOTIFY_REG);
      $setuphold (negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02,
                   NOTIFY_REG);
      $setuphold (negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02,
                   NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LSGCNHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge clock gating cell, high latch Enable, scan
//                      precontrol
//   last modified by : XLICDD generated
//****************************************************************************

module LSGCNHDX4 (CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E, delay_SE, d_dat_i, c_SH_E, c_SH_SE,
                   c_SH_E_v, c_SH_SE_v;

   or        i0  (d_dat_i, delay_E, delay_SE);
   u_ld1     i1  (IQ, d_dat_i, delay_CLK, NOTIFY_REG);
   not       i2  (n_0, IQ);
   or        i3  (GCLK, delay_CLK, n_0);

   not       i4  (c_SH_E, delay_SE);
   not       i5  (c_SH_SE, delay_E);
   not #(0.01) i6  (c_SH_E_v, delay_SE);
   not #(0.01) i7  (c_SH_SE_v, delay_E);

// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_E);
      $setuphold (negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CLK, delay_E);

      $setuphold (negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_SE);
      $setuphold (negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_SE);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

   or        i0  (dat_i, E, SE);
   u_ld1     i1  (IQ, dat_i, CLK, NOTIFY_REG);
   not       i2  (n_0, IQ);
   or        i3  (GCLK, CLK, n_0);

   not       i4  (c_SH_E, SE);
   not       i5  (c_SH_SE, E);
   not #(0.01) i6  (c_SH_E_v, SE);
   not #(0.01) i7  (c_SH_SE_v, E);

// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02,
                   NOTIFY_REG);
      $setuphold (negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02,
                   NOTIFY_REG);
      $setuphold (negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02,
                   NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LSGCPHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge clock gating cell, low latch Enable, scan
//                      precontrol
//   last modified by : XLICDD generated
//****************************************************************************

module LSGCPHDX0 (CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E, delay_SE, d_clock_i, d_dat_i, c_SH_E,
                   c_SH_SE, c_SH_E_v, c_SH_SE_v;

   not       i0  (d_clock_i, delay_CLK);
   or        i1  (d_dat_i, delay_E, delay_SE);
   u_ld1     i2  (IQ, d_dat_i, d_clock_i, NOTIFY_REG);
   and       i3  (GCLK, delay_CLK, IQ);

   not       i4  (c_SH_E, delay_SE);
   not       i5  (c_SH_SE, delay_E);
   not #(0.01) i6  (c_SH_E_v, delay_SE);
   not #(0.01) i7  (c_SH_SE_v, delay_E);

// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_E);
      $setuphold (posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CLK, delay_E);

      $setuphold (posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_SE);
      $setuphold (posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_SE);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

   not       i0  (clock_i, CLK);
   or        i1  (dat_i, E, SE);
   u_ld1     i2  (IQ, dat_i, clock_i, NOTIFY_REG);
   and       i3  (GCLK, CLK, IQ);

   not       i4  (c_SH_E, SE);
   not       i5  (c_SH_SE, E);
   not #(0.01) i6  (c_SH_E_v, SE);
   not #(0.01) i7  (c_SH_SE_v, E);

// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02,
                   NOTIFY_REG);
      $setuphold (posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02,
                   NOTIFY_REG);
      $setuphold (posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02,
                   NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LSGCPHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge clock gating cell, low latch Enable, scan
//                      precontrol
//   last modified by : XLICDD generated
//****************************************************************************

module LSGCPHDX1 (CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E, delay_SE, d_clock_i, d_dat_i, c_SH_E,
                   c_SH_SE, c_SH_E_v, c_SH_SE_v;

   not       i0  (d_clock_i, delay_CLK);
   or        i1  (d_dat_i, delay_E, delay_SE);
   u_ld1     i2  (IQ, d_dat_i, d_clock_i, NOTIFY_REG);
   and       i3  (GCLK, delay_CLK, IQ);

   not       i4  (c_SH_E, delay_SE);
   not       i5  (c_SH_SE, delay_E);
   not #(0.01) i6  (c_SH_E_v, delay_SE);
   not #(0.01) i7  (c_SH_SE_v, delay_E);

// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_E);
      $setuphold (posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CLK, delay_E);

      $setuphold (posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_SE);
      $setuphold (posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_SE);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

   not       i0  (clock_i, CLK);
   or        i1  (dat_i, E, SE);
   u_ld1     i2  (IQ, dat_i, clock_i, NOTIFY_REG);
   and       i3  (GCLK, CLK, IQ);

   not       i4  (c_SH_E, SE);
   not       i5  (c_SH_SE, E);
   not #(0.01) i6  (c_SH_E_v, SE);
   not #(0.01) i7  (c_SH_SE_v, E);

// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02,
                   NOTIFY_REG);
      $setuphold (posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02,
                   NOTIFY_REG);
      $setuphold (posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02,
                   NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LSGCPHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge clock gating cell, low latch Enable, scan
//                      precontrol
//   last modified by : XLICDD generated
//****************************************************************************

module LSGCPHDX2 (CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E, delay_SE, d_clock_i, d_dat_i, c_SH_E,
                   c_SH_SE, c_SH_E_v, c_SH_SE_v;

   not       i0  (d_clock_i, delay_CLK);
   or        i1  (d_dat_i, delay_E, delay_SE);
   u_ld1     i2  (IQ, d_dat_i, d_clock_i, NOTIFY_REG);
   and       i3  (GCLK, delay_CLK, IQ);

   not       i4  (c_SH_E, delay_SE);
   not       i5  (c_SH_SE, delay_E);
   not #(0.01) i6  (c_SH_E_v, delay_SE);
   not #(0.01) i7  (c_SH_SE_v, delay_E);

// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_E);
      $setuphold (posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CLK, delay_E);

      $setuphold (posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_SE);
      $setuphold (posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_SE);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

   not       i0  (clock_i, CLK);
   or        i1  (dat_i, E, SE);
   u_ld1     i2  (IQ, dat_i, clock_i, NOTIFY_REG);
   and       i3  (GCLK, CLK, IQ);

   not       i4  (c_SH_E, SE);
   not       i5  (c_SH_SE, E);
   not #(0.01) i6  (c_SH_E_v, SE);
   not #(0.01) i7  (c_SH_SE_v, E);

// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02,
                   NOTIFY_REG);
      $setuphold (posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02,
                   NOTIFY_REG);
      $setuphold (posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02,
                   NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LSGCPHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge clock gating cell, low latch Enable, scan
//                      precontrol
//   last modified by : XLICDD generated
//****************************************************************************

module LSGCPHDX4 (CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E, delay_SE, d_clock_i, d_dat_i, c_SH_E,
                   c_SH_SE, c_SH_E_v, c_SH_SE_v;

   not       i0  (d_clock_i, delay_CLK);
   or        i1  (d_dat_i, delay_E, delay_SE);
   u_ld1     i2  (IQ, d_dat_i, d_clock_i, NOTIFY_REG);
   and       i3  (GCLK, delay_CLK, IQ);

   not       i4  (c_SH_E, delay_SE);
   not       i5  (c_SH_SE, delay_E);
   not #(0.01) i6  (c_SH_E_v, delay_SE);
   not #(0.01) i7  (c_SH_SE_v, delay_E);

// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_E);
      $setuphold (posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CLK, delay_E);

      $setuphold (posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_SE);
      $setuphold (posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CLK, delay_SE);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

   not       i0  (clock_i, CLK);
   or        i1  (dat_i, E, SE);
   u_ld1     i2  (IQ, dat_i, clock_i, NOTIFY_REG);
   and       i3  (GCLK, CLK, IQ);

   not       i4  (c_SH_E, SE);
   not       i5  (c_SH_SE, E);
   not #(0.01) i6  (c_SH_E_v, SE);
   not #(0.01) i7  (c_SH_SE_v, E);

// timing section:
   specify

      (CLK +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02,
                   NOTIFY_REG);
      $setuphold (posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02,
                   NOTIFY_REG);
      $setuphold (posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02,
                   NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LSOGCNHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge clock gating cell, high latch Enable, scan
//                      postcontrol, obs_output
//   last modified by : XLICDD generated
//****************************************************************************

module LSOGCNHDX0 (CGOBS, CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E;

   u_ld1     i0  (IQ, delay_E, delay_CLK, NOTIFY_REG);
   buf       i1  (CGOBS, IQ);
   nor       i2  (n_1, IQ, SE);
   or        i4  (GCLK, delay_CLK, n_1);


// timing section:
   specify

      (E +=> CGOBS) = (0.02, 0.02);
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);

      (CLK +=> GCLK) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);
      $setuphold (negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ;

   u_ld1     i0  (IQ, E, CLK, NOTIFY_REG);
   buf       i1  (CGOBS, IQ);
   nor       i2  (n_1, IQ, SE);
   or        i4  (GCLK, CLK, n_1);


// timing section:
   specify

      (E +=> CGOBS) = (0.02, 0.02);
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);

      (CLK +=> GCLK) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LSOGCNHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge clock gating cell, high latch Enable, scan
//                      postcontrol, obs_output
//   last modified by : XLICDD generated
//****************************************************************************

module LSOGCNHDX1 (CGOBS, CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E;

   u_ld1     i0  (IQ, delay_E, delay_CLK, NOTIFY_REG);
   buf       i1  (CGOBS, IQ);
   nor       i2  (n_1, IQ, SE);
   or        i4  (GCLK, delay_CLK, n_1);


// timing section:
   specify

      (E +=> CGOBS) = (0.02, 0.02);
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);

      (CLK +=> GCLK) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);
      $setuphold (negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ;

   u_ld1     i0  (IQ, E, CLK, NOTIFY_REG);
   buf       i1  (CGOBS, IQ);
   nor       i2  (n_1, IQ, SE);
   or        i4  (GCLK, CLK, n_1);


// timing section:
   specify

      (E +=> CGOBS) = (0.02, 0.02);
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);

      (CLK +=> GCLK) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LSOGCNHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge clock gating cell, high latch Enable, scan
//                      postcontrol, obs_output
//   last modified by : XLICDD generated
//****************************************************************************

module LSOGCNHDX2 (CGOBS, CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E;

   u_ld1     i0  (IQ, delay_E, delay_CLK, NOTIFY_REG);
   buf       i1  (CGOBS, IQ);
   nor       i2  (n_1, IQ, SE);
   or        i4  (GCLK, delay_CLK, n_1);


// timing section:
   specify

      (E +=> CGOBS) = (0.02, 0.02);
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);

      (CLK +=> GCLK) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);
      $setuphold (negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ;

   u_ld1     i0  (IQ, E, CLK, NOTIFY_REG);
   buf       i1  (CGOBS, IQ);
   nor       i2  (n_1, IQ, SE);
   or        i4  (GCLK, CLK, n_1);


// timing section:
   specify

      (E +=> CGOBS) = (0.02, 0.02);
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);

      (CLK +=> GCLK) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LSOGCNHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge clock gating cell, high latch Enable, scan
//                      postcontrol, obs_output
//   last modified by : XLICDD generated
//****************************************************************************

module LSOGCNHDX4 (CGOBS, CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E;

   u_ld1     i0  (IQ, delay_E, delay_CLK, NOTIFY_REG);
   buf       i1  (CGOBS, IQ);
   nor       i2  (n_1, IQ, SE);
   or        i4  (GCLK, delay_CLK, n_1);


// timing section:
   specify

      (E +=> CGOBS) = (0.02, 0.02);
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);

      (CLK +=> GCLK) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);
      $setuphold (negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ;

   u_ld1     i0  (IQ, E, CLK, NOTIFY_REG);
   buf       i1  (CGOBS, IQ);
   nor       i2  (n_1, IQ, SE);
   or        i4  (GCLK, CLK, n_1);


// timing section:
   specify

      (E +=> CGOBS) = (0.02, 0.02);
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);

      (CLK +=> GCLK) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

      $setuphold (negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LSOGCPHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge clock gating cell, low latch Enable, scan
//                      postcontrol, obs_output
//   last modified by : XLICDD generated
//****************************************************************************

module LSOGCPHDX0 (CGOBS, CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E, d_clock_i;

   not       i0  (d_clock_i, delay_CLK);
   u_ld1     i1  (IQ, delay_E, d_clock_i, NOTIFY_REG);
   buf       i2  (CGOBS, IQ);
   or        i3  (n_1, IQ, SE);
   and       i4  (GCLK, delay_CLK, n_1);


// timing section:
   specify

      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);

      (CLK +=> GCLK) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);
      $setuphold (posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i;

   not       i0  (clock_i, CLK);
   u_ld1     i1  (IQ, E, clock_i, NOTIFY_REG);
   buf       i2  (CGOBS, IQ);
   or        i3  (n_1, IQ, SE);
   and       i4  (GCLK, CLK, n_1);


// timing section:
   specify

      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);

      (CLK +=> GCLK) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LSOGCPHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge clock gating cell, low latch Enable, scan
//                      postcontrol, obs_output
//   last modified by : XLICDD generated
//****************************************************************************

module LSOGCPHDX1 (CGOBS, CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E, d_clock_i;

   not       i0  (d_clock_i, delay_CLK);
   u_ld1     i1  (IQ, delay_E, d_clock_i, NOTIFY_REG);
   buf       i2  (CGOBS, IQ);
   or        i3  (n_1, IQ, SE);
   and       i4  (GCLK, delay_CLK, n_1);


// timing section:
   specify

      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);

      (CLK +=> GCLK) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);
      $setuphold (posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i;

   not       i0  (clock_i, CLK);
   u_ld1     i1  (IQ, E, clock_i, NOTIFY_REG);
   buf       i2  (CGOBS, IQ);
   or        i3  (n_1, IQ, SE);
   and       i4  (GCLK, CLK, n_1);


// timing section:
   specify

      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);

      (CLK +=> GCLK) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LSOGCPHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge clock gating cell, low latch Enable, scan
//                      postcontrol, obs_output
//   last modified by : XLICDD generated
//****************************************************************************

module LSOGCPHDX2 (CGOBS, CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E, d_clock_i;

   not       i0  (d_clock_i, delay_CLK);
   u_ld1     i1  (IQ, delay_E, d_clock_i, NOTIFY_REG);
   buf       i2  (CGOBS, IQ);
   or        i3  (n_1, IQ, SE);
   and       i4  (GCLK, delay_CLK, n_1);


// timing section:
   specify

      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);

      (CLK +=> GCLK) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);
      $setuphold (posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i;

   not       i0  (clock_i, CLK);
   u_ld1     i1  (IQ, E, clock_i, NOTIFY_REG);
   buf       i2  (CGOBS, IQ);
   or        i3  (n_1, IQ, SE);
   and       i4  (GCLK, CLK, n_1);


// timing section:
   specify

      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);

      (CLK +=> GCLK) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LSOGCPHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge clock gating cell, low latch Enable, scan
//                      postcontrol, obs_output
//   last modified by : XLICDD generated
//****************************************************************************

module LSOGCPHDX4 (CGOBS, CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CLK, delay_E, d_clock_i;

   not       i0  (d_clock_i, delay_CLK);
   u_ld1     i1  (IQ, delay_E, d_clock_i, NOTIFY_REG);
   buf       i2  (CGOBS, IQ);
   or        i3  (n_1, IQ, SE);
   and       i4  (GCLK, delay_CLK, n_1);


// timing section:
   specify

      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);

      (CLK +=> GCLK) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);
      $setuphold (posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK,
                   delay_E);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i;

   not       i0  (clock_i, CLK);
   u_ld1     i1  (IQ, E, clock_i, NOTIFY_REG);
   buf       i2  (CGOBS, IQ);
   or        i3  (n_1, IQ, SE);
   and       i4  (GCLK, CLK, n_1);


// timing section:
   specify

      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);

      (CLK +=> GCLK) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

      $setuphold (posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CLK, 0.02, 0, NOTIFY_REG);
      $width (negedge CLK, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : MU2IHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2:1 inverting Multiplexer
//   last modified by : XLICDD generated
//****************************************************************************

module MU2IHDX0 (IN0, IN1, Q, S);

   input     IN0, IN1, S;
   output    Q;

// Function Q: !((!S*IN0)+(S*IN1))
   u_mx2     i5  (n_3, IN0, IN1, S);
   not       i4  (Q, n_3);

// timing section:
   specify

      (posedge S => (Q +: Q)) = (0.02, 0.02);
      (negedge S => (Q +: Q)) = (0.02, 0.02);
         if ((IN0 == 1'b0 && IN1 == 1'b1)) (S -=> Q) = (0.02, 0.02);
      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : MU2IHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2:1 inverting Multiplexer
//   last modified by : XLICDD generated
//****************************************************************************

module MU2IHDX1 (IN0, IN1, Q, S);

   input     IN0, IN1, S;
   output    Q;

// Function Q: !((!S*IN0)+(S*IN1))
   u_mx2     i5  (n_3, IN0, IN1, S);
   not       i4  (Q, n_3);

// timing section:
   specify

      (posedge S => (Q +: Q)) = (0.02, 0.02);
      (negedge S => (Q +: Q)) = (0.02, 0.02);
         if ((IN0 == 1'b0 && IN1 == 1'b1)) (S -=> Q) = (0.02, 0.02);
      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : MU2IHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2:1 inverting Multiplexer
//   last modified by : XLICDD generated
//****************************************************************************

module MU2IHDX2 (IN0, IN1, Q, S);

   input     IN0, IN1, S;
   output    Q;

// Function Q: !((!S*IN0)+(S*IN1))
   u_mx2     i5  (n_3, IN0, IN1, S);
   not       i4  (Q, n_3);

// timing section:
   specify

      (posedge S => (Q +: Q)) = (0.02, 0.02);
      (negedge S => (Q +: Q)) = (0.02, 0.02);
         if ((IN0 == 1'b0 && IN1 == 1'b1)) (S -=> Q) = (0.02, 0.02);
      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : MU2IHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2:1 inverting Multiplexer
//   last modified by : XLICDD generated
//****************************************************************************

module MU2IHDX4 (IN0, IN1, Q, S);

   input     IN0, IN1, S;
   output    Q;

// Function Q: !((!S*IN0)+(S*IN1))
   u_mx2     i5  (n_3, IN0, IN1, S);
   not       i4  (Q, n_3);

// timing section:
   specify

      (posedge S => (Q +: Q)) = (0.02, 0.02);
      (negedge S => (Q +: Q)) = (0.02, 0.02);
         if ((IN0 == 1'b0 && IN1 == 1'b1)) (S -=> Q) = (0.02, 0.02);
      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : MU2HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2:1 Multiplexer
//   last modified by : XLICDD generated
//****************************************************************************

module MU2HDX0 (IN0, IN1, Q, S);

   input     IN0, IN1, S;
   output    Q;

// Function Q: (!S*IN0)+(S*IN1)
   u_mx2     i4  (Q, IN0, IN1, S);

// timing section:
   specify

      (posedge S => (Q +: Q)) = (0.02, 0.02);
      (negedge S => (Q +: Q)) = (0.02, 0.02);
         if ((IN0 == 1'b0 && IN1 == 1'b1)) (S +=> Q) = (0.02, 0.02);
      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : MU2HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2:1 Multiplexer
//   last modified by : XLICDD generated
//****************************************************************************

module MU2HDX1 (IN0, IN1, Q, S);

   input     IN0, IN1, S;
   output    Q;

// Function Q: (!S*IN0)+(S*IN1)
   u_mx2     i4  (Q, IN0, IN1, S);

// timing section:
   specify

      (posedge S => (Q +: Q)) = (0.02, 0.02);
      (negedge S => (Q +: Q)) = (0.02, 0.02);
         if ((IN0 == 1'b0 && IN1 == 1'b1)) (S +=> Q) = (0.02, 0.02);
      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : MU2HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2:1 Multiplexer
//   last modified by : XLICDD generated
//****************************************************************************

module MU2HDX2 (IN0, IN1, Q, S);

   input     IN0, IN1, S;
   output    Q;

// Function Q: (!S*IN0)+(S*IN1)
   u_mx2     i4  (Q, IN0, IN1, S);

// timing section:
   specify

      (posedge S => (Q +: Q)) = (0.02, 0.02);
      (negedge S => (Q +: Q)) = (0.02, 0.02);
         if ((IN0 == 1'b0 && IN1 == 1'b1)) (S +=> Q) = (0.02, 0.02);
      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : MU2HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2:1 Multiplexer
//   last modified by : XLICDD generated
//****************************************************************************

module MU2HDX4 (IN0, IN1, Q, S);

   input     IN0, IN1, S;
   output    Q;

// Function Q: (!S*IN0)+(S*IN1)
   u_mx2     i4  (Q, IN0, IN1, S);

// timing section:
   specify

      (posedge S => (Q +: Q)) = (0.02, 0.02);
      (negedge S => (Q +: Q)) = (0.02, 0.02);
         if ((IN0 == 1'b0 && IN1 == 1'b1)) (S +=> Q) = (0.02, 0.02);
      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
//*****************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : MU4IHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4:1 inverting Multiplexer
//   last modified by : XLICDD generated
//*****************************************************************

module MU4IHDX0 (IN0, IN1, IN2, IN3, Q, S0, S1);

   input   IN0, IN1, IN2, IN3, S0, S1;
   output  Q;

// logic section  
   u_mx2   i1 (n_0, IN0, IN1, S0);
   u_mx2   i2 (n_1, IN2, IN3, S0);
   u_mx2   i3 (n_2, n_0, n_1, S1);
   not     i4 (Q, n_2);
    

// timing section:
   specify

      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);
      (posedge S0 => (Q +: Q)) = (0.02, 0.02);
      (negedge S0 => (Q +: Q)) = (0.02, 0.02);
      (IN2 -=> Q) = (0.02, 0.02);
      (posedge S1 => (Q +: Q)) = (0.02, 0.02);
      (negedge S1 => (Q +: Q)) = (0.02, 0.02);
      (IN3 -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
//*****************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : MU4IHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4:1 inverting Multiplexer
//   last modified by : XLICDD generated
//*****************************************************************

module MU4IHDX1 (IN0, IN1, IN2, IN3, Q, S0, S1);

   input   IN0, IN1, IN2, IN3, S0, S1;
   output  Q;

// logic section  
   u_mx2   i1 (n_0, IN0, IN1, S0);
   u_mx2   i2 (n_1, IN2, IN3, S0);
   u_mx2   i3 (n_2, n_0, n_1, S1);
   not     i4 (Q, n_2);
    

// timing section:
   specify

      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);
      (posedge S0 => (Q +: Q)) = (0.02, 0.02);
      (negedge S0 => (Q +: Q)) = (0.02, 0.02);
      (IN2 -=> Q) = (0.02, 0.02);
      (posedge S1 => (Q +: Q)) = (0.02, 0.02);
      (negedge S1 => (Q +: Q)) = (0.02, 0.02);
      (IN3 -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
//*****************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : MU4IHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4:1 inverting Multiplexer
//   last modified by : XLICDD generated
//*****************************************************************

module MU4IHDX2 (IN0, IN1, IN2, IN3, Q, S0, S1);

   input   IN0, IN1, IN2, IN3, S0, S1;
   output  Q;

// logic section  
   u_mx2   i1 (n_0, IN0, IN1, S0);
   u_mx2   i2 (n_1, IN2, IN3, S0);
   u_mx2   i3 (n_2, n_0, n_1, S1);
   not     i4 (Q, n_2);
    

// timing section:
   specify

      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);
      (posedge S0 => (Q +: Q)) = (0.02, 0.02);
      (negedge S0 => (Q +: Q)) = (0.02, 0.02);
      (IN2 -=> Q) = (0.02, 0.02);
      (posedge S1 => (Q +: Q)) = (0.02, 0.02);
      (negedge S1 => (Q +: Q)) = (0.02, 0.02);
      (IN3 -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
//*****************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : MU4IHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4:1 inverting Multiplexer
//   last modified by : XLICDD generated
//*****************************************************************

module MU4IHDX4 (IN0, IN1, IN2, IN3, Q, S0, S1);

   input   IN0, IN1, IN2, IN3, S0, S1;
   output  Q;

// logic section  
   u_mx2   i1 (n_0, IN0, IN1, S0);
   u_mx2   i2 (n_1, IN2, IN3, S0);
   u_mx2   i3 (n_2, n_0, n_1, S1);
   not     i4 (Q, n_2);
    

// timing section:
   specify

      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);
      (posedge S0 => (Q +: Q)) = (0.02, 0.02);
      (negedge S0 => (Q +: Q)) = (0.02, 0.02);
      (IN2 -=> Q) = (0.02, 0.02);
      (posedge S1 => (Q +: Q)) = (0.02, 0.02);
      (negedge S1 => (Q +: Q)) = (0.02, 0.02);
      (IN3 -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
//*****************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : MU4HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4:1 Multiplexer
//   last modified by : XLICDD generated
//*****************************************************************

module MU4HDX0 (IN0, IN1, IN2, IN3, Q, S0, S1);

   input   IN0, IN1, IN2, IN3, S0, S1;
   output  Q;

// logic section  
   u_mx2   i1 (n_0, IN0, IN1, S0);
   u_mx2   i2 (n_1, IN2, IN3, S0);
   u_mx2   i3 (n_2, n_0, n_1, S1);
   buf     i4 (Q, n_2);
    

// timing section:
   specify

      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);
      (posedge S0 => (Q +: Q)) = (0.02, 0.02);
      (negedge S0 => (Q +: Q)) = (0.02, 0.02);
      (IN2 +=> Q) = (0.02, 0.02);
      (posedge S1 => (Q +: Q)) = (0.02, 0.02);
      (negedge S1 => (Q +: Q)) = (0.02, 0.02);
      (IN3 +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
//*****************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : MU4HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4:1 Multiplexer
//   last modified by : XLICDD generated
//*****************************************************************

module MU4HDX1 (IN0, IN1, IN2, IN3, Q, S0, S1);

   input   IN0, IN1, IN2, IN3, S0, S1;
   output  Q;

// logic section  
   u_mx2   i1 (n_0, IN0, IN1, S0);
   u_mx2   i2 (n_1, IN2, IN3, S0);
   u_mx2   i3 (n_2, n_0, n_1, S1);
   buf     i4 (Q, n_2);
    

// timing section:
   specify

      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);
      (posedge S0 => (Q +: Q)) = (0.02, 0.02);
      (negedge S0 => (Q +: Q)) = (0.02, 0.02);
      (IN2 +=> Q) = (0.02, 0.02);
      (posedge S1 => (Q +: Q)) = (0.02, 0.02);
      (negedge S1 => (Q +: Q)) = (0.02, 0.02);
      (IN3 +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
//*****************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : MU4HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4:1 Multiplexer
//   last modified by : XLICDD generated
//*****************************************************************

module MU4HDX2 (IN0, IN1, IN2, IN3, Q, S0, S1);

   input   IN0, IN1, IN2, IN3, S0, S1;
   output  Q;

// logic section  
   u_mx2   i1 (n_0, IN0, IN1, S0);
   u_mx2   i2 (n_1, IN2, IN3, S0);
   u_mx2   i3 (n_2, n_0, n_1, S1);
   buf     i4 (Q, n_2);
    

// timing section:
   specify

      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);
      (posedge S0 => (Q +: Q)) = (0.02, 0.02);
      (negedge S0 => (Q +: Q)) = (0.02, 0.02);
      (IN2 +=> Q) = (0.02, 0.02);
      (posedge S1 => (Q +: Q)) = (0.02, 0.02);
      (negedge S1 => (Q +: Q)) = (0.02, 0.02);
      (IN3 +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
//*****************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : MU4HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4:1 Multiplexer
//   last modified by : XLICDD generated
//*****************************************************************

module MU4HDX4 (IN0, IN1, IN2, IN3, Q, S0, S1);

   input   IN0, IN1, IN2, IN3, S0, S1;
   output  Q;

// logic section  
   u_mx2   i1 (n_0, IN0, IN1, S0);
   u_mx2   i2 (n_1, IN2, IN3, S0);
   u_mx2   i3 (n_2, n_0, n_1, S1);
   buf     i4 (Q, n_2);
    

// timing section:
   specify

      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);
      (posedge S0 => (Q +: Q)) = (0.02, 0.02);
      (negedge S0 => (Q +: Q)) = (0.02, 0.02);
      (IN2 +=> Q) = (0.02, 0.02);
      (posedge S1 => (Q +: Q)) = (0.02, 0.02);
      (negedge S1 => (Q +: Q)) = (0.02, 0.02);
      (IN3 +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA22HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NAND into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA22HDX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !(!(A*B)*C)
   nand      i0  (n_1, A, B);
   nand      i2  (Q, n_1, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA22HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NAND into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA22HDX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !(!(A*B)*C)
   nand      i0  (n_1, A, B);
   nand      i2  (Q, n_1, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA22HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NAND into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA22HDX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !(!(A*B)*C)
   nand      i0  (n_1, A, B);
   nand      i2  (Q, n_1, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA22HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NAND into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA22HDX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !(!(A*B)*C)
   nand      i0  (n_1, A, B);
   nand      i2  (Q, n_1, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA2I1HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NAND with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA2I1HDX0 (AN, B, Q);

   input     AN, B;
   output    Q;

// Function Q: !(!AN*B)
   not       i0  (n_0, AN);
   nand      i1  (Q, n_0, B);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA2I1HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NAND with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA2I1HDX1 (AN, B, Q);

   input     AN, B;
   output    Q;

// Function Q: !(!AN*B)
   not       i0  (n_0, AN);
   nand      i1  (Q, n_0, B);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA2I1HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NAND with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA2I1HDX2 (AN, B, Q);

   input     AN, B;
   output    Q;

// Function Q: !(!AN*B)
   not       i0  (n_0, AN);
   nand      i1  (Q, n_0, B);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA2I1HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NAND with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA2I1HDX4 (AN, B, Q);

   input     AN, B;
   output    Q;

// Function Q: !(!AN*B)
   not       i0  (n_0, AN);
   nand      i1  (Q, n_0, B);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA2HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA2HDX0 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: !(A*B)
   nand      i0  (Q, A, B);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA2HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA2HDX1 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: !(A*B)
   nand      i0  (Q, A, B);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA2HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA2HDX2 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: !(A*B)
   nand      i0  (Q, A, B);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA2HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA2HDX4 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: !(A*B)
   nand      i0  (Q, A, B);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA3I1HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NAND with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA3I1HDX0 (AN, B, C, Q);

   input     AN, B, C;
   output    Q;

// Function Q: !(!AN*B*C)
   not       i0  (n_0, AN);
   nand      i1  (Q, n_0, B, C);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA3I1HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NAND with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA3I1HDX1 (AN, B, C, Q);

   input     AN, B, C;
   output    Q;

// Function Q: !(!AN*B*C)
   not       i0  (n_0, AN);
   nand      i1  (Q, n_0, B, C);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA3I1HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NAND with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA3I1HDX2 (AN, B, C, Q);

   input     AN, B, C;
   output    Q;

// Function Q: !(!AN*B*C)
   not       i0  (n_0, AN);
   nand      i1  (Q, n_0, B, C);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA3I1HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NAND with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA3I1HDX4 (AN, B, C, Q);

   input     AN, B, C;
   output    Q;

// Function Q: !(!AN*B*C)
   not       i0  (n_0, AN);
   nand      i1  (Q, n_0, B, C);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA3I2HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NAND with 2 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA3I2HDX0 (AN, BN, C, Q);

   input     AN, BN, C;
   output    Q;

// Function Q: !(!AN*!BN*C)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nand      i2  (Q, n_0, n_1, C);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA3I2HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NAND with 2 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA3I2HDX1 (AN, BN, C, Q);

   input     AN, BN, C;
   output    Q;

// Function Q: !(!AN*!BN*C)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nand      i2  (Q, n_0, n_1, C);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA3I2HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NAND with 2 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA3I2HDX2 (AN, BN, C, Q);

   input     AN, BN, C;
   output    Q;

// Function Q: !(!AN*!BN*C)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nand      i2  (Q, n_0, n_1, C);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA3I2HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NAND with 2 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA3I2HDX4 (AN, BN, C, Q);

   input     AN, BN, C;
   output    Q;

// Function Q: !(!AN*!BN*C)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nand      i2  (Q, n_0, n_1, C);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA3HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA3HDX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !(A*B*C)
   nand      i0  (Q, A, B, C);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA3HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA3HDX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !(A*B*C)
   nand      i0  (Q, A, B, C);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA3HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA3HDX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !(A*B*C)
   nand      i0  (Q, A, B, C);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA3HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA3HDX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !(A*B*C)
   nand      i0  (Q, A, B, C);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA4I1HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NAND with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA4I1HDX0 (AN, B, C, D, Q);

   input     AN, B, C, D;
   output    Q;

// Function Q: !(!AN*B*C*D)
   not       i0  (n_0, AN);
   nand      i1  (Q, n_0, B, C, D);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA4I1HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NAND with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA4I1HDX1 (AN, B, C, D, Q);

   input     AN, B, C, D;
   output    Q;

// Function Q: !(!AN*B*C*D)
   not       i0  (n_0, AN);
   nand      i1  (Q, n_0, B, C, D);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA4I1HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NAND with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA4I1HDX2 (AN, B, C, D, Q);

   input     AN, B, C, D;
   output    Q;

// Function Q: !(!AN*B*C*D)
   not       i0  (n_0, AN);
   nand      i1  (Q, n_0, B, C, D);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA4I1HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NAND with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA4I1HDX4 (AN, B, C, D, Q);

   input     AN, B, C, D;
   output    Q;

// Function Q: !(!AN*B*C*D)
   not       i0  (n_0, AN);
   nand      i1  (Q, n_0, B, C, D);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA4I2HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NAND with 2 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA4I2HDX0 (AN, BN, C, D, Q);

   input     AN, BN, C, D;
   output    Q;

// Function Q: !(!AN*!BN*C*D)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nand      i2  (Q, n_0, n_1, C, D);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA4I2HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NAND with 2 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA4I2HDX1 (AN, BN, C, D, Q);

   input     AN, BN, C, D;
   output    Q;

// Function Q: !(!AN*!BN*C*D)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nand      i2  (Q, n_0, n_1, C, D);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA4I2HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NAND with 2 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA4I2HDX2 (AN, BN, C, D, Q);

   input     AN, BN, C, D;
   output    Q;

// Function Q: !(!AN*!BN*C*D)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nand      i2  (Q, n_0, n_1, C, D);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA4I2HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NAND with 2 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA4I2HDX4 (AN, BN, C, D, Q);

   input     AN, BN, C, D;
   output    Q;

// Function Q: !(!AN*!BN*C*D)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nand      i2  (Q, n_0, n_1, C, D);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA4I3HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NAND with 3 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA4I3HDX0 (AN, BN, CN, D, Q);

   input     AN, BN, CN, D;
   output    Q;

// Function Q: !(!AN*!BN*!CN*D)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nand      i3  (Q, n_0, n_1, n_2, D);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA4I3HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NAND with 3 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA4I3HDX1 (AN, BN, CN, D, Q);

   input     AN, BN, CN, D;
   output    Q;

// Function Q: !(!AN*!BN*!CN*D)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nand      i3  (Q, n_0, n_1, n_2, D);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA4I3HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NAND with 3 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA4I3HDX2 (AN, BN, CN, D, Q);

   input     AN, BN, CN, D;
   output    Q;

// Function Q: !(!AN*!BN*!CN*D)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nand      i3  (Q, n_0, n_1, n_2, D);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA4I3HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NAND with 3 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA4I3HDX4 (AN, BN, CN, D, Q);

   input     AN, BN, CN, D;
   output    Q;

// Function Q: !(!AN*!BN*!CN*D)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nand      i3  (Q, n_0, n_1, n_2, D);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA4HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA4HDX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !(A*B*C*D)
   nand      i0  (Q, A, B, C, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA4HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA4HDX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !(A*B*C*D)
   nand      i0  (Q, A, B, C, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA4HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA4HDX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !(A*B*C*D)
   nand      i0  (Q, A, B, C, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA4HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA4HDX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !(A*B*C*D)
   nand      i0  (Q, A, B, C, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA5I1HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA5I1HDX0 (AN, B, C, D, E, Q);

   input     AN, B, C, D, E;
   output    Q;

// Function Q: !(!AN*B*C*D*E)
   not       i0  (n_0, AN);
   nand      i1  (Q, n_0, B, C, D, E);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA5I1HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA5I1HDX1 (AN, B, C, D, E, Q);

   input     AN, B, C, D, E;
   output    Q;

// Function Q: !(!AN*B*C*D*E)
   not       i0  (n_0, AN);
   nand      i1  (Q, n_0, B, C, D, E);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA5I1HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA5I1HDX2 (AN, B, C, D, E, Q);

   input     AN, B, C, D, E;
   output    Q;

// Function Q: !(!AN*B*C*D*E)
   not       i0  (n_0, AN);
   nand      i1  (Q, n_0, B, C, D, E);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA5I1HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA5I1HDX4 (AN, B, C, D, E, Q);

   input     AN, B, C, D, E;
   output    Q;

// Function Q: !(!AN*B*C*D*E)
   not       i0  (n_0, AN);
   nand      i1  (Q, n_0, B, C, D, E);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA5I2HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND with 2 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA5I2HDX0 (AN, BN, C, D, E, Q);

   input     AN, BN, C, D, E;
   output    Q;

// Function Q: !(!AN*!BN*C*D*E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nand      i2  (Q, n_0, n_1, C, D, E);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA5I2HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND with 2 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA5I2HDX1 (AN, BN, C, D, E, Q);

   input     AN, BN, C, D, E;
   output    Q;

// Function Q: !(!AN*!BN*C*D*E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nand      i2  (Q, n_0, n_1, C, D, E);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA5I2HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND with 2 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA5I2HDX2 (AN, BN, C, D, E, Q);

   input     AN, BN, C, D, E;
   output    Q;

// Function Q: !(!AN*!BN*C*D*E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nand      i2  (Q, n_0, n_1, C, D, E);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA5I2HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND with 2 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA5I2HDX4 (AN, BN, C, D, E, Q);

   input     AN, BN, C, D, E;
   output    Q;

// Function Q: !(!AN*!BN*C*D*E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nand      i2  (Q, n_0, n_1, C, D, E);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA5I3HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA5I3HDX0 (AN, BN, CN, D, E, Q);

   input     AN, BN, CN, D, E;
   output    Q;

// Function Q: !(!AN*!BN*!CN*D*E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nand      i3  (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA5I3HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA5I3HDX1 (AN, BN, CN, D, E, Q);

   input     AN, BN, CN, D, E;
   output    Q;

// Function Q: !(!AN*!BN*!CN*D*E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nand      i3  (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA5I3HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA5I3HDX2 (AN, BN, CN, D, E, Q);

   input     AN, BN, CN, D, E;
   output    Q;

// Function Q: !(!AN*!BN*!CN*D*E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nand      i3  (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA5I3HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA5I3HDX4 (AN, BN, CN, D, E, Q);

   input     AN, BN, CN, D, E;
   output    Q;

// Function Q: !(!AN*!BN*!CN*D*E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nand      i3  (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA5I4HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND with 4 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA5I4HDX0 (AN, BN, CN, DN, E, Q);

   input     AN, BN, CN, DN, E;
   output    Q;

// Function Q: !(!AN*!BN*!CN*!DN*E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   nand      i4  (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify

      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA5I4HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND with 4 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA5I4HDX1 (AN, BN, CN, DN, E, Q);

   input     AN, BN, CN, DN, E;
   output    Q;

// Function Q: !(!AN*!BN*!CN*!DN*E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   nand      i4  (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify

      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA5I4HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND with 4 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA5I4HDX2 (AN, BN, CN, DN, E, Q);

   input     AN, BN, CN, DN, E;
   output    Q;

// Function Q: !(!AN*!BN*!CN*!DN*E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   nand      i4  (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify

      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA5I4HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND with 4 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA5I4HDX4 (AN, BN, CN, DN, E, Q);

   input     AN, BN, CN, DN, E;
   output    Q;

// Function Q: !(!AN*!BN*!CN*!DN*E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   nand      i4  (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify

      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA5HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA5HDX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !(A*B*C*D*E)
   nand      i0  (Q, A, B, C, D, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA5HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA5HDX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !(A*B*C*D*E)
   nand      i0  (Q, A, B, C, D, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA5HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA5HDX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !(A*B*C*D*E)
   nand      i0  (Q, A, B, C, D, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA5HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA5HDX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !(A*B*C*D*E)
   nand      i0  (Q, A, B, C, D, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6I1HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA6I1HDX0 (AN, B, C, D, E, F, Q);

   input     AN, B, C, D, E, F;
   output    Q;

// Function Q: !(!AN*B*C*D*E*F)
   not       i0  (n_0, AN);
   nand      i1  (Q, n_0, B, C, D, E, F);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6I1HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA6I1HDX1 (AN, B, C, D, E, F, Q);

   input     AN, B, C, D, E, F;
   output    Q;

// Function Q: !(!AN*B*C*D*E*F)
   not       i0  (n_0, AN);
   nand      i1  (Q, n_0, B, C, D, E, F);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6I1HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA6I1HDX2 (AN, B, C, D, E, F, Q);

   input     AN, B, C, D, E, F;
   output    Q;

// Function Q: !(!AN*B*C*D*E*F)
   not       i0  (n_0, AN);
   nand      i1  (Q, n_0, B, C, D, E, F);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6I1HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NA6I1HDX4 (AN, B, C, D, E, F, Q);

   input     AN, B, C, D, E, F;
   output    Q;

// Function Q: !(!AN*B*C*D*E*F)
   not       i0  (n_0, AN);
   nand      i1  (Q, n_0, B, C, D, E, F);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6I2HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND with 2 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA6I2HDX0 (AN, BN, C, D, E, F, Q);

   input     AN, BN, C, D, E, F;
   output    Q;

// Function Q: !(!AN*!BN*C*D*E*F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nand      i2  (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6I2HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND with 2 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA6I2HDX1 (AN, BN, C, D, E, F, Q);

   input     AN, BN, C, D, E, F;
   output    Q;

// Function Q: !(!AN*!BN*C*D*E*F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nand      i2  (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6I2HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND with 2 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA6I2HDX2 (AN, BN, C, D, E, F, Q);

   input     AN, BN, C, D, E, F;
   output    Q;

// Function Q: !(!AN*!BN*C*D*E*F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nand      i2  (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6I2HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND with 2 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA6I2HDX4 (AN, BN, C, D, E, F, Q);

   input     AN, BN, C, D, E, F;
   output    Q;

// Function Q: !(!AN*!BN*C*D*E*F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nand      i2  (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6I3HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND with 3 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA6I3HDX0 (AN, BN, CN, D, E, F, Q);

   input     AN, BN, CN, D, E, F;
   output    Q;

// Function Q: !(!AN*!BN*!CN*D*E*F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nand      i3  (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6I3HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND with 3 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA6I3HDX1 (AN, BN, CN, D, E, F, Q);

   input     AN, BN, CN, D, E, F;
   output    Q;

// Function Q: !(!AN*!BN*!CN*D*E*F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nand      i3  (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6I3HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND with 3 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA6I3HDX2 (AN, BN, CN, D, E, F, Q);

   input     AN, BN, CN, D, E, F;
   output    Q;

// Function Q: !(!AN*!BN*!CN*D*E*F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nand      i3  (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6I3HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND with 3 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA6I3HDX4 (AN, BN, CN, D, E, F, Q);

   input     AN, BN, CN, D, E, F;
   output    Q;

// Function Q: !(!AN*!BN*!CN*D*E*F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nand      i3  (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6I4HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND with 4 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA6I4HDX0 (AN, BN, CN, DN, E, F, Q);

   input     AN, BN, CN, DN, E, F;
   output    Q;

// Function Q: !(!AN*!BN*!CN*!DN*E*F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   nand      i4  (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify

      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6I4HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND with 4 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA6I4HDX1 (AN, BN, CN, DN, E, F, Q);

   input     AN, BN, CN, DN, E, F;
   output    Q;

// Function Q: !(!AN*!BN*!CN*!DN*E*F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   nand      i4  (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify

      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6I4HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND with 4 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA6I4HDX2 (AN, BN, CN, DN, E, F, Q);

   input     AN, BN, CN, DN, E, F;
   output    Q;

// Function Q: !(!AN*!BN*!CN*!DN*E*F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   nand      i4  (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify

      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6I4HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND with 4 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA6I4HDX4 (AN, BN, CN, DN, E, F, Q);

   input     AN, BN, CN, DN, E, F;
   output    Q;

// Function Q: !(!AN*!BN*!CN*!DN*E*F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   nand      i4  (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify

      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6I5HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND with 5 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA6I5HDX0 (AN, BN, CN, DN, EN, F, Q);

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// Function Q: !(!AN*!BN*!CN*!DN*!EN*F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   not       i4  (n_4, EN);
   nand      i5  (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify

      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6I5HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND with 5 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA6I5HDX1 (AN, BN, CN, DN, EN, F, Q);

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// Function Q: !(!AN*!BN*!CN*!DN*!EN*F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   not       i4  (n_4, EN);
   nand      i5  (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify

      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6I5HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND with 5 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA6I5HDX2 (AN, BN, CN, DN, EN, F, Q);

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// Function Q: !(!AN*!BN*!CN*!DN*!EN*F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   not       i4  (n_4, EN);
   nand      i5  (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify

      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6I5HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND with 5 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NA6I5HDX4 (AN, BN, CN, DN, EN, F, Q);

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// Function Q: !(!AN*!BN*!CN*!DN*!EN*F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   not       i4  (n_4, EN);
   nand      i5  (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify

      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA6HDX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !(A*B*C*D*E*F)
   nand      i0  (Q, A, B, C, D, E, F);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA6HDX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !(A*B*C*D*E*F)
   nand      i0  (Q, A, B, C, D, E, F);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA6HDX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !(A*B*C*D*E*F)
   nand      i0  (Q, A, B, C, D, E, F);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NA6HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module NA6HDX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !(A*B*C*D*E*F)
   nand      i0  (Q, A, B, C, D, E, F);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO22HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NOR into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO22HDX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !(!(A+B)+C)
   nor       i0  (n_1, A, B);
   nor       i2  (Q, n_1, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO22HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NOR into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO22HDX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !(!(A+B)+C)
   nor       i0  (n_1, A, B);
   nor       i2  (Q, n_1, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO22HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NOR into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO22HDX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !(!(A+B)+C)
   nor       i0  (n_1, A, B);
   nor       i2  (Q, n_1, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO22HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NOR into 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO22HDX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !(!(A+B)+C)
   nor       i0  (n_1, A, B);
   nor       i2  (Q, n_1, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO2I1HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NOR with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO2I1HDX0 (AN, B, Q);

   input     AN, B;
   output    Q;

// Function Q: !(!AN+B)
   not       i0  (n_0, AN);
   nor       i1  (Q, n_0, B);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO2I1HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NOR with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO2I1HDX1 (AN, B, Q);

   input     AN, B;
   output    Q;

// Function Q: !(!AN+B)
   not       i0  (n_0, AN);
   nor       i1  (Q, n_0, B);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO2I1HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NOR with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO2I1HDX2 (AN, B, Q);

   input     AN, B;
   output    Q;

// Function Q: !(!AN+B)
   not       i0  (n_0, AN);
   nor       i1  (Q, n_0, B);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO2I1HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NOR with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO2I1HDX4 (AN, B, Q);

   input     AN, B;
   output    Q;

// Function Q: !(!AN+B)
   not       i0  (n_0, AN);
   nor       i1  (Q, n_0, B);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO2HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO2HDX0 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: !(A+B)
   nor       i0  (Q, A, B);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO2HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO2HDX1 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: !(A+B)
   nor       i0  (Q, A, B);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO2HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO2HDX2 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: !(A+B)
   nor       i0  (Q, A, B);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO2HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO2HDX4 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: !(A+B)
   nor       i0  (Q, A, B);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO3I1HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NOR with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO3I1HDX0 (AN, B, C, Q);

   input     AN, B, C;
   output    Q;

// Function Q: !(!AN+B+C)
   not       i0  (n_0, AN);
   nor       i1  (Q, n_0, B, C);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO3I1HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NOR with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO3I1HDX1 (AN, B, C, Q);

   input     AN, B, C;
   output    Q;

// Function Q: !(!AN+B+C)
   not       i0  (n_0, AN);
   nor       i1  (Q, n_0, B, C);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO3I1HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NOR with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO3I1HDX2 (AN, B, C, Q);

   input     AN, B, C;
   output    Q;

// Function Q: !(!AN+B+C)
   not       i0  (n_0, AN);
   nor       i1  (Q, n_0, B, C);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO3I1HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NOR with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO3I1HDX4 (AN, B, C, Q);

   input     AN, B, C;
   output    Q;

// Function Q: !(!AN+B+C)
   not       i0  (n_0, AN);
   nor       i1  (Q, n_0, B, C);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO3I2HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NOR with 2 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO3I2HDX0 (AN, BN, C, Q);

   input     AN, BN, C;
   output    Q;

// Function Q: !(!AN+!BN+C)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nor       i2  (Q, n_0, n_1, C);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO3I2HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NOR with 2 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO3I2HDX1 (AN, BN, C, Q);

   input     AN, BN, C;
   output    Q;

// Function Q: !(!AN+!BN+C)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nor       i2  (Q, n_0, n_1, C);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO3I2HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NOR with 2 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO3I2HDX2 (AN, BN, C, Q);

   input     AN, BN, C;
   output    Q;

// Function Q: !(!AN+!BN+C)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nor       i2  (Q, n_0, n_1, C);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO3I2HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NOR with 2 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO3I2HDX4 (AN, BN, C, Q);

   input     AN, BN, C;
   output    Q;

// Function Q: !(!AN+!BN+C)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nor       i2  (Q, n_0, n_1, C);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO3HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO3HDX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !(A+B+C)
   nor       i0  (Q, A, B, C);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO3HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO3HDX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !(A+B+C)
   nor       i0  (Q, A, B, C);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO3HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO3HDX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !(A+B+C)
   nor       i0  (Q, A, B, C);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO3HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO3HDX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !(A+B+C)
   nor       i0  (Q, A, B, C);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO4I1HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NOR with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO4I1HDX0 (AN, B, C, D, Q);

   input     AN, B, C, D;
   output    Q;

// Function Q: !(!AN+B+C+D)
   not       i0  (n_0, AN);
   nor       i1  (Q, n_0, B, C, D);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO4I1HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NOR with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO4I1HDX1 (AN, B, C, D, Q);

   input     AN, B, C, D;
   output    Q;

// Function Q: !(!AN+B+C+D)
   not       i0  (n_0, AN);
   nor       i1  (Q, n_0, B, C, D);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO4I1HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NOR with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO4I1HDX2 (AN, B, C, D, Q);

   input     AN, B, C, D;
   output    Q;

// Function Q: !(!AN+B+C+D)
   not       i0  (n_0, AN);
   nor       i1  (Q, n_0, B, C, D);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO4I1HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NOR with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO4I1HDX4 (AN, B, C, D, Q);

   input     AN, B, C, D;
   output    Q;

// Function Q: !(!AN+B+C+D)
   not       i0  (n_0, AN);
   nor       i1  (Q, n_0, B, C, D);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO4I2HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NOR with 2 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NO4I2HDX0 (AN, BN, C, D, Q);

   input     AN, BN, C, D;
   output    Q;

// Function Q: !(!AN+!BN+C+D)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nor       i2  (Q, n_0, n_1, C, D);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO4I2HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NOR with 2 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NO4I2HDX1 (AN, BN, C, D, Q);

   input     AN, BN, C, D;
   output    Q;

// Function Q: !(!AN+!BN+C+D)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nor       i2  (Q, n_0, n_1, C, D);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO4I2HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NOR with 2 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NO4I2HDX2 (AN, BN, C, D, Q);

   input     AN, BN, C, D;
   output    Q;

// Function Q: !(!AN+!BN+C+D)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nor       i2  (Q, n_0, n_1, C, D);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO4I2HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NOR with 2 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NO4I2HDX4 (AN, BN, C, D, Q);

   input     AN, BN, C, D;
   output    Q;

// Function Q: !(!AN+!BN+C+D)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nor       i2  (Q, n_0, n_1, C, D);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO4I3HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NOR with 3 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NO4I3HDX0 (AN, BN, CN, D, Q);

   input     AN, BN, CN, D;
   output    Q;

// Function Q: !(!AN+!BN+!CN+D)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nor       i3  (Q, n_0, n_1, n_2, D);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO4I3HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NOR with 3 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NO4I3HDX1 (AN, BN, CN, D, Q);

   input     AN, BN, CN, D;
   output    Q;

// Function Q: !(!AN+!BN+!CN+D)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nor       i3  (Q, n_0, n_1, n_2, D);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO4I3HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NOR with 3 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NO4I3HDX2 (AN, BN, CN, D, Q);

   input     AN, BN, CN, D;
   output    Q;

// Function Q: !(!AN+!BN+!CN+D)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nor       i3  (Q, n_0, n_1, n_2, D);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO4I3HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NOR with 3 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NO4I3HDX4 (AN, BN, CN, D, Q);

   input     AN, BN, CN, D;
   output    Q;

// Function Q: !(!AN+!BN+!CN+D)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nor       i3  (Q, n_0, n_1, n_2, D);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO4HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO4HDX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !(A+B+C+D)
   nor       i0  (Q, A, B, C, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO4HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO4HDX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !(A+B+C+D)
   nor       i0  (Q, A, B, C, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO4HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO4HDX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !(A+B+C+D)
   nor       i0  (Q, A, B, C, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO4HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO4HDX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !(A+B+C+D)
   nor       i0  (Q, A, B, C, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO5I1HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NOR with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO5I1HDX0 (AN, B, C, D, E, Q);

   input     AN, B, C, D, E;
   output    Q;

// Function Q: !(!AN+B+C+D+E)
   not       i0  (n_0, AN);
   nor       i1  (Q, n_0, B, C, D, E);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO5I1HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NOR with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO5I1HDX1 (AN, B, C, D, E, Q);

   input     AN, B, C, D, E;
   output    Q;

// Function Q: !(!AN+B+C+D+E)
   not       i0  (n_0, AN);
   nor       i1  (Q, n_0, B, C, D, E);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO5I1HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NOR with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO5I1HDX2 (AN, B, C, D, E, Q);

   input     AN, B, C, D, E;
   output    Q;

// Function Q: !(!AN+B+C+D+E)
   not       i0  (n_0, AN);
   nor       i1  (Q, n_0, B, C, D, E);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO5I1HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NOR with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO5I1HDX4 (AN, B, C, D, E, Q);

   input     AN, B, C, D, E;
   output    Q;

// Function Q: !(!AN+B+C+D+E)
   not       i0  (n_0, AN);
   nor       i1  (Q, n_0, B, C, D, E);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO5I2HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NOR with 2 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NO5I2HDX0 (AN, BN, C, D, E, Q);

   input     AN, BN, C, D, E;
   output    Q;

// Function Q: !(!AN+!BN+C+D+E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nor       i2  (Q, n_0, n_1, C, D, E);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO5I2HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NOR with 2 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NO5I2HDX1 (AN, BN, C, D, E, Q);

   input     AN, BN, C, D, E;
   output    Q;

// Function Q: !(!AN+!BN+C+D+E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nor       i2  (Q, n_0, n_1, C, D, E);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO5I2HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NOR with 2 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NO5I2HDX2 (AN, BN, C, D, E, Q);

   input     AN, BN, C, D, E;
   output    Q;

// Function Q: !(!AN+!BN+C+D+E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nor       i2  (Q, n_0, n_1, C, D, E);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO5I2HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NOR with 2 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NO5I2HDX4 (AN, BN, C, D, E, Q);

   input     AN, BN, C, D, E;
   output    Q;

// Function Q: !(!AN+!BN+C+D+E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nor       i2  (Q, n_0, n_1, C, D, E);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO5I3HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NO5I3HDX0 (AN, BN, CN, D, E, Q);

   input     AN, BN, CN, D, E;
   output    Q;

// Function Q: !(!AN+!BN+!CN+D+E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nor       i3  (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO5I3HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NO5I3HDX1 (AN, BN, CN, D, E, Q);

   input     AN, BN, CN, D, E;
   output    Q;

// Function Q: !(!AN+!BN+!CN+D+E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nor       i3  (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO5I3HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NO5I3HDX2 (AN, BN, CN, D, E, Q);

   input     AN, BN, CN, D, E;
   output    Q;

// Function Q: !(!AN+!BN+!CN+D+E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nor       i3  (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO5I3HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NO5I3HDX4 (AN, BN, CN, D, E, Q);

   input     AN, BN, CN, D, E;
   output    Q;

// Function Q: !(!AN+!BN+!CN+D+E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nor       i3  (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO5I4HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NOR with 4 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NO5I4HDX0 (AN, BN, CN, DN, E, Q);

   input     AN, BN, CN, DN, E;
   output    Q;

// Function Q: !(!AN+!BN+!CN+!DN+E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   nor       i4  (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify

      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO5I4HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NOR with 4 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NO5I4HDX1 (AN, BN, CN, DN, E, Q);

   input     AN, BN, CN, DN, E;
   output    Q;

// Function Q: !(!AN+!BN+!CN+!DN+E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   nor       i4  (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify

      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO5I4HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NOR with 4 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NO5I4HDX2 (AN, BN, CN, DN, E, Q);

   input     AN, BN, CN, DN, E;
   output    Q;

// Function Q: !(!AN+!BN+!CN+!DN+E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   nor       i4  (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify

      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO5I4HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NOR with 4 inverted inputs
//   last modified by : XLICDD generated
//****************************************************************************

module NO5I4HDX4 (AN, BN, CN, DN, E, Q);

   input     AN, BN, CN, DN, E;
   output    Q;

// Function Q: !(!AN+!BN+!CN+!DN+E)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   nor       i4  (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify

      (E -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO5HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO5HDX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !(A+B+C+D+E)
   nor       i0  (Q, A, B, C, D, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO5HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO5HDX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !(A+B+C+D+E)
   nor       i0  (Q, A, B, C, D, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO5HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO5HDX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !(A+B+C+D+E)
   nor       i0  (Q, A, B, C, D, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO5HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO5HDX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !(A+B+C+D+E)
   nor       i0  (Q, A, B, C, D, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6I1HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO6I1HDX0 (AN, B, C, D, E, F, Q);

   input     AN, B, C, D, E, F;
   output    Q;

// Function Q: !(!AN+B+C+D+E+F)
   not       i0  (n_0, AN);
   nor       i1  (Q, n_0, B, C, D, E, F);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6I1HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO6I1HDX1 (AN, B, C, D, E, F, Q);

   input     AN, B, C, D, E, F;
   output    Q;

// Function Q: !(!AN+B+C+D+E+F)
   not       i0  (n_0, AN);
   nor       i1  (Q, n_0, B, C, D, E, F);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6I1HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO6I1HDX2 (AN, B, C, D, E, F, Q);

   input     AN, B, C, D, E, F;
   output    Q;

// Function Q: !(!AN+B+C+D+E+F)
   not       i0  (n_0, AN);
   nor       i1  (Q, n_0, B, C, D, E, F);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6I1HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR with 1 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO6I1HDX4 (AN, B, C, D, E, F, Q);

   input     AN, B, C, D, E, F;
   output    Q;

// Function Q: !(!AN+B+C+D+E+F)
   not       i0  (n_0, AN);
   nor       i1  (Q, n_0, B, C, D, E, F);

// timing section:
   specify

      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6I2HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR with 2 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO6I2HDX0 (AN, BN, C, D, E, F, Q);

   input     AN, BN, C, D, E, F;
   output    Q;

// Function Q: !(!AN+!BN+C+D+E+F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nor       i2  (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6I2HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR with 2 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO6I2HDX1 (AN, BN, C, D, E, F, Q);

   input     AN, BN, C, D, E, F;
   output    Q;

// Function Q: !(!AN+!BN+C+D+E+F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nor       i2  (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6I2HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR with 2 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO6I2HDX2 (AN, BN, C, D, E, F, Q);

   input     AN, BN, C, D, E, F;
   output    Q;

// Function Q: !(!AN+!BN+C+D+E+F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nor       i2  (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6I2HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR with 2 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO6I2HDX4 (AN, BN, C, D, E, F, Q);

   input     AN, BN, C, D, E, F;
   output    Q;

// Function Q: !(!AN+!BN+C+D+E+F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   nor       i2  (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify

      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6I3HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR with 3 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO6I3HDX0 (AN, BN, CN, D, E, F, Q);

   input     AN, BN, CN, D, E, F;
   output    Q;

// Function Q: !(!AN+!BN+!CN+D+E+F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nor       i3  (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6I3HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR with 3 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO6I3HDX1 (AN, BN, CN, D, E, F, Q);

   input     AN, BN, CN, D, E, F;
   output    Q;

// Function Q: !(!AN+!BN+!CN+D+E+F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nor       i3  (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6I3HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR with 3 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO6I3HDX2 (AN, BN, CN, D, E, F, Q);

   input     AN, BN, CN, D, E, F;
   output    Q;

// Function Q: !(!AN+!BN+!CN+D+E+F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nor       i3  (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6I3HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR with 3 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO6I3HDX4 (AN, BN, CN, D, E, F, Q);

   input     AN, BN, CN, D, E, F;
   output    Q;

// Function Q: !(!AN+!BN+!CN+D+E+F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   nor       i3  (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify

      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6I4HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR with 4 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO6I4HDX0 (AN, BN, CN, DN, E, F, Q);

   input     AN, BN, CN, DN, E, F;
   output    Q;

// Function Q: !(!AN+!BN+!CN+!DN+E+F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   nor       i4  (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify

      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6I4HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR with 4 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO6I4HDX1 (AN, BN, CN, DN, E, F, Q);

   input     AN, BN, CN, DN, E, F;
   output    Q;

// Function Q: !(!AN+!BN+!CN+!DN+E+F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   nor       i4  (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify

      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6I4HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR with 4 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO6I4HDX2 (AN, BN, CN, DN, E, F, Q);

   input     AN, BN, CN, DN, E, F;
   output    Q;

// Function Q: !(!AN+!BN+!CN+!DN+E+F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   nor       i4  (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify

      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6I4HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR with 4 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO6I4HDX4 (AN, BN, CN, DN, E, F, Q);

   input     AN, BN, CN, DN, E, F;
   output    Q;

// Function Q: !(!AN+!BN+!CN+!DN+E+F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   nor       i4  (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify

      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6I5HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR with 5 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO6I5HDX0 (AN, BN, CN, DN, EN, F, Q);

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// Function Q: !(!AN+!BN+!CN+!DN+!EN+F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   not       i4  (n_4, EN);
   nor       i5  (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify

      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6I5HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR with 5 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO6I5HDX1 (AN, BN, CN, DN, EN, F, Q);

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// Function Q: !(!AN+!BN+!CN+!DN+!EN+F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   not       i4  (n_4, EN);
   nor       i5  (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify

      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6I5HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR with 5 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO6I5HDX2 (AN, BN, CN, DN, EN, F, Q);

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// Function Q: !(!AN+!BN+!CN+!DN+!EN+F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   not       i4  (n_4, EN);
   nor       i5  (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify

      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6I5HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR with 5 inverted input
//   last modified by : XLICDD generated
//****************************************************************************

module NO6I5HDX4 (AN, BN, CN, DN, EN, F, Q);

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// Function Q: !(!AN+!BN+!CN+!DN+!EN+F)
   not       i0  (n_0, AN);
   not       i1  (n_1, BN);
   not       i2  (n_2, CN);
   not       i3  (n_3, DN);
   not       i4  (n_4, EN);
   nor       i5  (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify

      (F -=> Q) = (0.02, 0.02);
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO6HDX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !(A+B+C+D+E+F)
   nor       i0  (Q, A, B, C, D, E, F);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO6HDX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !(A+B+C+D+E+F)
   nor       i0  (Q, A, B, C, D, E, F);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO6HDX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !(A+B+C+D+E+F)
   nor       i0  (Q, A, B, C, D, E, F);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : NO6HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input NOR
//   last modified by : XLICDD generated
//****************************************************************************

module NO6HDX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !(A+B+C+D+E+F)
   nor       i0  (Q, A, B, C, D, E, F);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA211HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input OR into 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA211HDX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A+B)*C*D)
   or        i0  (n_0, A, B);
   and       i1  (Q, n_0, C, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA211HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input OR into 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA211HDX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A+B)*C*D)
   or        i0  (n_0, A, B);
   and       i1  (Q, n_0, C, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA211HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input OR into 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA211HDX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A+B)*C*D)
   or        i0  (n_0, A, B);
   and       i1  (Q, n_0, C, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA211HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input OR into 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA211HDX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A+B)*C*D)
   or        i0  (n_0, A, B);
   and       i1  (Q, n_0, C, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA21HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input OR into 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA21HDX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: ((A+B)*C)
   or        i0  (n_0, A, B);
   and       i1  (Q, n_0, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA21HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input OR into 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA21HDX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: ((A+B)*C)
   or        i0  (n_0, A, B);
   and       i1  (Q, n_0, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA21HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input OR into 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA21HDX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: ((A+B)*C)
   or        i0  (n_0, A, B);
   and       i1  (Q, n_0, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA21HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input OR into 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA21HDX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: ((A+B)*C)
   or        i0  (n_0, A, B);
   and       i1  (Q, n_0, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA221HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input OR into 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA221HDX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A+B)*(C+D)*E)
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   and       i2  (Q, n_0, n_1, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A +=> Q) =
                   (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B +=> Q) =
                   (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C +=> Q) =
                   (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D +=> Q) =
                   (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1
                   && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E +=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA221HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input OR into 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA221HDX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A+B)*(C+D)*E)
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   and       i2  (Q, n_0, n_1, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A +=> Q) =
                   (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B +=> Q) =
                   (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C +=> Q) =
                   (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D +=> Q) =
                   (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1
                   && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E +=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA221HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input OR into 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA221HDX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A+B)*(C+D)*E)
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   and       i2  (Q, n_0, n_1, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A +=> Q) =
                   (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B +=> Q) =
                   (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C +=> Q) =
                   (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D +=> Q) =
                   (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1
                   && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E +=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA221HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input OR into 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA221HDX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A+B)*(C+D)*E)
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   and       i2  (Q, n_0, n_1, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A +=> Q) =
                   (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B +=> Q) =
                   (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C +=> Q) =
                   (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D +=> Q) =
                   (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1
                   && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E +=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA222HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3x2 Input OR into 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA222HDX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A+B)*(C+D)*(E+F))
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   or        i2  (n_2, E, F);
   and       i3  (Q, n_0, n_1, n_2);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1))
                   (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1))
                   (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA222HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3x2 Input OR into 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA222HDX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A+B)*(C+D)*(E+F))
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   or        i2  (n_2, E, F);
   and       i3  (Q, n_0, n_1, n_2);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1))
                   (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1))
                   (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA222HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3x2 Input OR into 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA222HDX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A+B)*(C+D)*(E+F))
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   or        i2  (n_2, E, F);
   and       i3  (Q, n_0, n_1, n_2);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1))
                   (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1))
                   (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA222HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3x2 Input OR into 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA222HDX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A+B)*(C+D)*(E+F))
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   or        i2  (n_2, E, F);
   and       i3  (Q, n_0, n_1, n_2);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1))
                   (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1))
                   (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA22HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input OR into 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA22HDX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A+B)*(C+D))
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   and       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA22HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input OR into 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA22HDX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A+B)*(C+D))
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   and       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA22HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input OR into 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA22HDX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A+B)*(C+D))
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   and       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA22HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input OR into 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA22HDX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A+B)*(C+D))
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   and       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA311HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR into 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA311HDX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A+B+C)*D*E)
   or        i0  (n_0, A, B, C);
   and       i1  (Q, n_0, D, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA311HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR into 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA311HDX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A+B+C)*D*E)
   or        i0  (n_0, A, B, C);
   and       i1  (Q, n_0, D, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA311HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR into 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA311HDX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A+B+C)*D*E)
   or        i0  (n_0, A, B, C);
   and       i1  (Q, n_0, D, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA311HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR into 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA311HDX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A+B+C)*D*E)
   or        i0  (n_0, A, B, C);
   and       i1  (Q, n_0, D, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA31HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR into 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA31HDX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A+B+C)*D)
   or        i0  (n_0, A, B, C);
   and       i1  (Q, n_0, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA31HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR into 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA31HDX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A+B+C)*D)
   or        i0  (n_0, A, B, C);
   and       i1  (Q, n_0, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA31HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR into 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA31HDX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A+B+C)*D)
   or        i0  (n_0, A, B, C);
   and       i1  (Q, n_0, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA31HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR into 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA31HDX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: ((A+B+C)*D)
   or        i0  (n_0, A, B, C);
   and       i1  (Q, n_0, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA321HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR, 2-Input OR into 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA321HDX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A+B+C)*(D+E)*F)
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E);
   and       i2  (Q, n_0, n_1, F);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || (A == 1'b0
                   && B == 1'b1 && C == 1'b0 && E == 1'b1) || (A == 1'b0 && B
                   == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D ==
                   1'b1 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || (B == 1'b0
                   && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02,
                   0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0))
                   (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA321HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR, 2-Input OR into 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA321HDX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A+B+C)*(D+E)*F)
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E);
   and       i2  (Q, n_0, n_1, F);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || (A == 1'b0
                   && B == 1'b1 && C == 1'b0 && E == 1'b1) || (A == 1'b0 && B
                   == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D ==
                   1'b1 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || (B == 1'b0
                   && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02,
                   0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0))
                   (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA321HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR, 2-Input OR into 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA321HDX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A+B+C)*(D+E)*F)
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E);
   and       i2  (Q, n_0, n_1, F);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || (A == 1'b0
                   && B == 1'b1 && C == 1'b0 && E == 1'b1) || (A == 1'b0 && B
                   == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D ==
                   1'b1 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || (B == 1'b0
                   && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02,
                   0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0))
                   (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA321HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR, 2-Input OR into 3-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA321HDX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A+B+C)*(D+E)*F)
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E);
   and       i2  (Q, n_0, n_1, F);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || (A == 1'b0
                   && B == 1'b1 && C == 1'b0 && E == 1'b1) || (A == 1'b0 && B
                   == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D ==
                   1'b1 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || (B == 1'b0
                   && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02,
                   0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0))
                   (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA32HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR, 2-Input OR into 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA32HDX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A+B+C)*(D+E))
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E);
   and       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA32HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR, 2-Input OR into 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA32HDX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A+B+C)*(D+E))
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E);
   and       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA32HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR, 2-Input OR into 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA32HDX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A+B+C)*(D+E))
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E);
   and       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA32HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR, 2-Input OR into 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA32HDX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: ((A+B+C)*(D+E))
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E);
   and       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA33HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x3-Input OR into 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA33HDX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A+B+C)*(D+E+F))
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E, F);
   and       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA33HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x3-Input OR into 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA33HDX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A+B+C)*(D+E+F))
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E, F);
   and       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA33HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x3-Input OR into 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA33HDX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A+B+C)*(D+E+F))
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E, F);
   and       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OA33HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x3-Input OR into 2-Input AND
//   last modified by : XLICDD generated
//****************************************************************************

module OA33HDX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: ((A+B+C)*(D+E+F))
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E, F);
   and       i2  (Q, n_0, n_1);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON211HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input OR into 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON211HDX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A+B)*C*D)
   or        i0  (n_0, A, B);
   nand      i1  (Q, n_0, C, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON211HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input OR into 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON211HDX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A+B)*C*D)
   or        i0  (n_0, A, B);
   nand      i1  (Q, n_0, C, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON211HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input OR into 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON211HDX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A+B)*C*D)
   or        i0  (n_0, A, B);
   nand      i1  (Q, n_0, C, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON211HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input OR into 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON211HDX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A+B)*C*D)
   or        i0  (n_0, A, B);
   nand      i1  (Q, n_0, C, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON21HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input OR into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON21HDX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !((A+B)*C)
   or        i0  (n_0, A, B);
   nand      i1  (Q, n_0, C);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON21HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input OR into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON21HDX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !((A+B)*C)
   or        i0  (n_0, A, B);
   nand      i1  (Q, n_0, C);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON21HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input OR into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON21HDX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !((A+B)*C)
   or        i0  (n_0, A, B);
   nand      i1  (Q, n_0, C);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON21HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input OR into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON21HDX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: !((A+B)*C)
   or        i0  (n_0, A, B);
   nand      i1  (Q, n_0, C);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON221HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input OR into 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON221HDX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A+B)*(C+D)*E)
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   nand      i2  (Q, n_0, n_1, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A -=> Q) =
                   (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B -=> Q) =
                   (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C -=> Q) =
                   (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D -=> Q) =
                   (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1
                   && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E -=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON221HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input OR into 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON221HDX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A+B)*(C+D)*E)
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   nand      i2  (Q, n_0, n_1, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A -=> Q) =
                   (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B -=> Q) =
                   (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C -=> Q) =
                   (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D -=> Q) =
                   (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1
                   && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E -=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON221HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input OR into 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON221HDX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A+B)*(C+D)*E)
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   nand      i2  (Q, n_0, n_1, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A -=> Q) =
                   (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B -=> Q) =
                   (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C -=> Q) =
                   (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D -=> Q) =
                   (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1
                   && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E -=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON221HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input OR into 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON221HDX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A+B)*(C+D)*E)
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   nand      i2  (Q, n_0, n_1, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A -=> Q) =
                   (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B -=> Q) =
                   (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C -=> Q) =
                   (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D -=> Q) =
                   (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1
                   && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E -=> Q) =
                   (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON222HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3x2 Input OR into 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON222HDX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A+B)*(C+D)*(E+F))
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   or        i2  (n_2, E, F);
   nand      i3  (Q, n_0, n_1, n_2);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1))
                   (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1))
                   (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON222HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3x2 Input OR into 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON222HDX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A+B)*(C+D)*(E+F))
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   or        i2  (n_2, E, F);
   nand      i3  (Q, n_0, n_1, n_2);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1))
                   (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1))
                   (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON222HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3x2 Input OR into 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON222HDX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A+B)*(C+D)*(E+F))
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   or        i2  (n_2, E, F);
   nand      i3  (Q, n_0, n_1, n_2);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1))
                   (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1))
                   (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON222HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3x2 Input OR into 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON222HDX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A+B)*(C+D)*(E+F))
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   or        i2  (n_2, E, F);
   nand      i3  (Q, n_0, n_1, n_2);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1))
                   (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1))
                   (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON22HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input OR into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON22HDX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A+B)*(C+D))
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   nand      i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON22HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input OR into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON22HDX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A+B)*(C+D))
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   nand      i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON22HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input OR into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON22HDX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A+B)*(C+D))
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   nand      i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON22HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x2-Input OR into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON22HDX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A+B)*(C+D))
   or        i0  (n_0, A, B);
   or        i1  (n_1, C, D);
   nand      i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON311HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR into 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON311HDX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A+B+C)*D*E)
   or        i0  (n_0, A, B, C);
   nand      i1  (Q, n_0, D, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON311HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR into 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON311HDX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A+B+C)*D*E)
   or        i0  (n_0, A, B, C);
   nand      i1  (Q, n_0, D, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON311HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR into 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON311HDX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A+B+C)*D*E)
   or        i0  (n_0, A, B, C);
   nand      i1  (Q, n_0, D, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON311HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR into 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON311HDX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A+B+C)*D*E)
   or        i0  (n_0, A, B, C);
   nand      i1  (Q, n_0, D, E);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON31HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON31HDX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A+B+C)*D)
   or        i0  (n_0, A, B, C);
   nand      i1  (Q, n_0, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON31HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON31HDX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A+B+C)*D)
   or        i0  (n_0, A, B, C);
   nand      i1  (Q, n_0, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON31HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON31HDX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A+B+C)*D)
   or        i0  (n_0, A, B, C);
   nand      i1  (Q, n_0, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON31HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON31HDX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: !((A+B+C)*D)
   or        i0  (n_0, A, B, C);
   nand      i1  (Q, n_0, D);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON321HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR, 2-Input OR into 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON321HDX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A+B+C)*(D+E)*F)
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E);
   nand      i2  (Q, n_0, n_1, F);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || (A == 1'b0
                   && B == 1'b1 && C == 1'b0 && E == 1'b1) || (A == 1'b0 && B
                   == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D ==
                   1'b1 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || (B == 1'b0
                   && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02,
                   0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0))
                   (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON321HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR, 2-Input OR into 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON321HDX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A+B+C)*(D+E)*F)
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E);
   nand      i2  (Q, n_0, n_1, F);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || (A == 1'b0
                   && B == 1'b1 && C == 1'b0 && E == 1'b1) || (A == 1'b0 && B
                   == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D ==
                   1'b1 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || (B == 1'b0
                   && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02,
                   0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0))
                   (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON321HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR, 2-Input OR into 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON321HDX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A+B+C)*(D+E)*F)
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E);
   nand      i2  (Q, n_0, n_1, F);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || (A == 1'b0
                   && B == 1'b1 && C == 1'b0 && E == 1'b1) || (A == 1'b0 && B
                   == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D ==
                   1'b1 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || (B == 1'b0
                   && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02,
                   0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0))
                   (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON321HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR, 2-Input OR into 3-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON321HDX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A+B+C)*(D+E)*F)
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E);
   nand      i2  (Q, n_0, n_1, F);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1))
                   (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || (A == 1'b0
                   && B == 1'b1 && C == 1'b0 && E == 1'b1) || (A == 1'b0 && B
                   == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D ==
                   1'b1 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
         if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || (B == 1'b0
                   && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02,
                   0.02);
         if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0))
                   (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON32HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR, 2-Input OR into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON32HDX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A+B+C)*(D+E))
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E);
   nand      i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON32HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR, 2-Input OR into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON32HDX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A+B+C)*(D+E))
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E);
   nand      i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON32HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR, 2-Input OR into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON32HDX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A+B+C)*(D+E))
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E);
   nand      i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON32HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR, 2-Input OR into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON32HDX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: !((A+B+C)*(D+E))
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E);
   nand      i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON33HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x3-Input OR into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON33HDX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A+B+C)*(D+E+F))
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E, F);
   nand      i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON33HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x3-Input OR into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON33HDX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A+B+C)*(D+E+F))
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E, F);
   nand      i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON33HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x3-Input OR into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON33HDX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A+B+C)*(D+E+F))
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E, F);
   nand      i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ON33HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2x3-Input OR into 2-Input NAND
//   last modified by : XLICDD generated
//****************************************************************************

module ON33HDX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: !((A+B+C)*(D+E+F))
   or        i0  (n_0, A, B, C);
   or        i1  (n_1, D, E, F);
   nand      i2  (Q, n_0, n_1);

// timing section:
   specify

      (A -=> Q) = (0.02, 0.02);
         if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
         if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
         if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OR2HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module OR2HDX0 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: (A+B)
   or        i0  (Q, A, B);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OR2HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module OR2HDX1 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: (A+B)
   or        i0  (Q, A, B);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OR2HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module OR2HDX2 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: (A+B)
   or        i0  (Q, A, B);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OR2HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 2-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module OR2HDX4 (A, B, Q);

   input     A, B;
   output    Q;

// Function Q: (A+B)
   or        i0  (Q, A, B);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OR3HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module OR3HDX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: (A+B+C)
   or        i0  (Q, A, B, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OR3HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module OR3HDX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: (A+B+C)
   or        i0  (Q, A, B, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OR3HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module OR3HDX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: (A+B+C)
   or        i0  (Q, A, B, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OR3HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 3-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module OR3HDX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// Function Q: (A+B+C)
   or        i0  (Q, A, B, C);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OR4HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module OR4HDX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: (A+B+C+D)
   or        i0  (Q, A, B, C, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OR4HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module OR4HDX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: (A+B+C+D)
   or        i0  (Q, A, B, C, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OR4HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module OR4HDX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: (A+B+C+D)
   or        i0  (Q, A, B, C, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OR4HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 4-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module OR4HDX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// Function Q: (A+B+C+D)
   or        i0  (Q, A, B, C, D);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OR5HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module OR5HDX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: (A+B+C+D+E)
   or        i0  (Q, A, B, C, D, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OR5HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module OR5HDX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: (A+B+C+D+E)
   or        i0  (Q, A, B, C, D, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OR5HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module OR5HDX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: (A+B+C+D+E)
   or        i0  (Q, A, B, C, D, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OR5HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 5-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module OR5HDX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// Function Q: (A+B+C+D+E)
   or        i0  (Q, A, B, C, D, E);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OR6HDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module OR6HDX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: (A+B+C+D+E+F)
   or        i0  (Q, A, B, C, D, E, F);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OR6HDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module OR6HDX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: (A+B+C+D+E+F)
   or        i0  (Q, A, B, C, D, E, F);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OR6HDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module OR6HDX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: (A+B+C+D+E+F)
   or        i0  (Q, A, B, C, D, E, F);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : OR6HDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : 6-Input OR
//   last modified by : XLICDD generated
//****************************************************************************

module OR6HDX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// Function Q: (A+B+C+D+E+F)
   or        i0  (Q, A, B, C, D, E, F);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFHDX0 (CN, D, Q, QN, SD, SE);

   input     CN, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, d_clock_i, d_dat_i,
                   IQN, c_SH_D, c_SH_SD;

   not       i0  (d_clock_i, delay_CN);
   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   not       i10 (c_SH_D, delay_SE);
   buf       i11 (c_SH_SD, delay_SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, IQN, c_SH_D, c_SH_SD;

   not       i0  (clock_i, CN);
   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   not       i10 (c_SH_D, SE);
   buf       i11 (c_SH_SD, SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFHDX1 (CN, D, Q, QN, SD, SE);

   input     CN, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, d_clock_i, d_dat_i,
                   IQN, c_SH_D, c_SH_SD;

   not       i0  (d_clock_i, delay_CN);
   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   not       i10 (c_SH_D, delay_SE);
   buf       i11 (c_SH_SD, delay_SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, IQN, c_SH_D, c_SH_SD;

   not       i0  (clock_i, CN);
   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   not       i10 (c_SH_D, SE);
   buf       i11 (c_SH_SD, SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFHDX2 (CN, D, Q, QN, SD, SE);

   input     CN, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, d_clock_i, d_dat_i,
                   IQN, c_SH_D, c_SH_SD;

   not       i0  (d_clock_i, delay_CN);
   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   not       i10 (c_SH_D, delay_SE);
   buf       i11 (c_SH_SD, delay_SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, IQN, c_SH_D, c_SH_SD;

   not       i0  (clock_i, CN);
   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   not       i10 (c_SH_D, SE);
   buf       i11 (c_SH_SD, SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFHDX4 (CN, D, Q, QN, SD, SE);

   input     CN, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, d_clock_i, d_dat_i,
                   IQN, c_SH_D, c_SH_SD;

   not       i0  (d_clock_i, delay_CN);
   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   not       i10 (c_SH_D, delay_SE);
   buf       i11 (c_SH_SD, delay_SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, IQN, c_SH_D, c_SH_SD;

   not       i0  (clock_i, CN);
   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   not       i10 (c_SH_D, SE);
   buf       i11 (c_SH_SD, SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFQHDX0 (CN, D, Q, SD, SE);

   input     CN, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, d_clock_i, d_dat_i,
                   c_SH_D, c_SH_SD;

   not       i0  (d_clock_i, delay_CN);
   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i7  (Q, IQ);

   not       i8  (c_SH_D, delay_SE);
   buf       i9  (c_SH_SD, delay_SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, c_SH_D, c_SH_SD;

   not       i0  (clock_i, CN);
   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i7  (Q, IQ);

   not       i8  (c_SH_D, SE);
   buf       i9  (c_SH_SD, SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFQHDX1 (CN, D, Q, SD, SE);

   input     CN, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, d_clock_i, d_dat_i,
                   c_SH_D, c_SH_SD;

   not       i0  (d_clock_i, delay_CN);
   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i7  (Q, IQ);

   not       i8  (c_SH_D, delay_SE);
   buf       i9  (c_SH_SD, delay_SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, c_SH_D, c_SH_SD;

   not       i0  (clock_i, CN);
   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i7  (Q, IQ);

   not       i8  (c_SH_D, SE);
   buf       i9  (c_SH_SD, SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFQHDX2 (CN, D, Q, SD, SE);

   input     CN, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, d_clock_i, d_dat_i,
                   c_SH_D, c_SH_SD;

   not       i0  (d_clock_i, delay_CN);
   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i7  (Q, IQ);

   not       i8  (c_SH_D, delay_SE);
   buf       i9  (c_SH_SD, delay_SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, c_SH_D, c_SH_SD;

   not       i0  (clock_i, CN);
   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i7  (Q, IQ);

   not       i8  (c_SH_D, SE);
   buf       i9  (c_SH_SD, SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFQHDX4 (CN, D, Q, SD, SE);

   input     CN, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, d_clock_i, d_dat_i,
                   c_SH_D, c_SH_SD;

   not       i0  (d_clock_i, delay_CN);
   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, d_clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i7  (Q, IQ);

   not       i8  (c_SH_D, delay_SE);
   buf       i9  (c_SH_SD, delay_SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, c_SH_D, c_SH_SD;

   not       i0  (clock_i, CN);
   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
   buf       i7  (Q, IQ);

   not       i8  (c_SH_D, SE);
   buf       i9  (c_SH_SD, SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFRHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Reset and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFRHDX0 (CN, D, Q, QN, RN, SD, SE);

   input     CN, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_RN, d_clock_i,
                   d_dat_i, IQN, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (d_clock_i, delay_CN);
   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, d_clock_i, delay_RN, 1'b1, NOTIFY_REG);
   not       i8  (IQN, IQ);
   buf       i9  (Q, IQ);
   buf       i10 (QN, IQN);

   checkrs   i11 (c_SH_d_dat_i, delay_RN, 1'b1);
   not       i12 (SE_not, delay_SE);
   and       i13 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i14 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (clock_i, CN);
   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, clock_i, RN, 1'b1, NOTIFY_REG);
   not       i8  (IQN, IQ);
   buf       i9  (Q, IQ);
   buf       i10 (QN, IQN);

   checkrs   i11 (c_SH_dat_i, RN, 1'b1);
   not       i12 (SE_not, SE);
   and       i13 (c_SH_D, c_SH_dat_i, SE_not);
   and       i14 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFRHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Reset and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFRHDX1 (CN, D, Q, QN, RN, SD, SE);

   input     CN, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_RN, d_clock_i,
                   d_dat_i, IQN, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (d_clock_i, delay_CN);
   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, d_clock_i, delay_RN, 1'b1, NOTIFY_REG);
   not       i8  (IQN, IQ);
   buf       i9  (Q, IQ);
   buf       i10 (QN, IQN);

   checkrs   i11 (c_SH_d_dat_i, delay_RN, 1'b1);
   not       i12 (SE_not, delay_SE);
   and       i13 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i14 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (clock_i, CN);
   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, clock_i, RN, 1'b1, NOTIFY_REG);
   not       i8  (IQN, IQ);
   buf       i9  (Q, IQ);
   buf       i10 (QN, IQN);

   checkrs   i11 (c_SH_dat_i, RN, 1'b1);
   not       i12 (SE_not, SE);
   and       i13 (c_SH_D, c_SH_dat_i, SE_not);
   and       i14 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFRHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Reset and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFRHDX2 (CN, D, Q, QN, RN, SD, SE);

   input     CN, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_RN, d_clock_i,
                   d_dat_i, IQN, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (d_clock_i, delay_CN);
   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, d_clock_i, delay_RN, 1'b1, NOTIFY_REG);
   not       i8  (IQN, IQ);
   buf       i9  (Q, IQ);
   buf       i10 (QN, IQN);

   checkrs   i11 (c_SH_d_dat_i, delay_RN, 1'b1);
   not       i12 (SE_not, delay_SE);
   and       i13 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i14 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (clock_i, CN);
   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, clock_i, RN, 1'b1, NOTIFY_REG);
   not       i8  (IQN, IQ);
   buf       i9  (Q, IQ);
   buf       i10 (QN, IQN);

   checkrs   i11 (c_SH_dat_i, RN, 1'b1);
   not       i12 (SE_not, SE);
   and       i13 (c_SH_D, c_SH_dat_i, SE_not);
   and       i14 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFRHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Reset and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFRHDX4 (CN, D, Q, QN, RN, SD, SE);

   input     CN, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_RN, d_clock_i,
                   d_dat_i, IQN, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (d_clock_i, delay_CN);
   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, d_clock_i, delay_RN, 1'b1, NOTIFY_REG);
   not       i8  (IQN, IQ);
   buf       i9  (Q, IQ);
   buf       i10 (QN, IQN);

   checkrs   i11 (c_SH_d_dat_i, delay_RN, 1'b1);
   not       i12 (SE_not, delay_SE);
   and       i13 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i14 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (clock_i, CN);
   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, clock_i, RN, 1'b1, NOTIFY_REG);
   not       i8  (IQN, IQ);
   buf       i9  (Q, IQ);
   buf       i10 (QN, IQN);

   checkrs   i11 (c_SH_dat_i, RN, 1'b1);
   not       i12 (SE_not, SE);
   and       i13 (c_SH_D, c_SH_dat_i, SE_not);
   and       i14 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFRQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFRQHDX0 (CN, D, Q, RN, SD, SE);

   input     CN, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_RN, d_clock_i,
                   d_dat_i, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (d_clock_i, delay_CN);
   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, d_clock_i, delay_RN, 1'b1, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_d_dat_i, delay_RN, 1'b1);
   not       i10 (SE_not, delay_SE);
   and       i11 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (clock_i, CN);
   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, clock_i, RN, 1'b1, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_dat_i, RN, 1'b1);
   not       i10 (SE_not, SE);
   and       i11 (c_SH_D, c_SH_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFRQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFRQHDX1 (CN, D, Q, RN, SD, SE);

   input     CN, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_RN, d_clock_i,
                   d_dat_i, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (d_clock_i, delay_CN);
   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, d_clock_i, delay_RN, 1'b1, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_d_dat_i, delay_RN, 1'b1);
   not       i10 (SE_not, delay_SE);
   and       i11 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (clock_i, CN);
   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, clock_i, RN, 1'b1, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_dat_i, RN, 1'b1);
   not       i10 (SE_not, SE);
   and       i11 (c_SH_D, c_SH_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFRQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFRQHDX2 (CN, D, Q, RN, SD, SE);

   input     CN, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_RN, d_clock_i,
                   d_dat_i, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (d_clock_i, delay_CN);
   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, d_clock_i, delay_RN, 1'b1, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_d_dat_i, delay_RN, 1'b1);
   not       i10 (SE_not, delay_SE);
   and       i11 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (clock_i, CN);
   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, clock_i, RN, 1'b1, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_dat_i, RN, 1'b1);
   not       i10 (SE_not, SE);
   and       i11 (c_SH_D, c_SH_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFRQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFRQHDX4 (CN, D, Q, RN, SD, SE);

   input     CN, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_RN, d_clock_i,
                   d_dat_i, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (d_clock_i, delay_CN);
   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, d_clock_i, delay_RN, 1'b1, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_d_dat_i, delay_RN, 1'b1);
   not       i10 (SE_not, delay_SE);
   and       i11 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (clock_i, CN);
   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, clock_i, RN, 1'b1, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_dat_i, RN, 1'b1);
   not       i10 (SE_not, SE);
   and       i11 (c_SH_D, c_SH_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFRSHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFRSHDX0 (CN, D, Q, QN, RN, SD, SE, SN);

   input     CN, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_RN, delay_SN,
                   d_clock_i, d_dat_i, IQN, qin_and_set, c_SH_d_dat_i, SE_not,
                   c_SH_D, c_SH_SD;

   not       i1  (d_clock_i, delay_CN);
   u_mx2     i7  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i8  (IQ, d_dat_i, d_clock_i, delay_RN, delay_SN, NOTIFY_REG);
   not       i9  (IQN, IQ);
   and       i10 (qin_and_set, IQN, delay_SN);
   buf       i11 (Q, IQ);
   buf       i12 (QN, qin_and_set);

   checkrs   i13 (c_SH_d_dat_i, delay_RN, delay_SN);
   not       i14 (SE_not, delay_SE);
   and       i15 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i16 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, IQN, qin_and_set, c_SH_dat_i, SE_not, c_SH_D,
                   c_SH_SD;

   not       i1  (clock_i, CN);
   u_mx2     i7  (dat_i, D, SD, SE);
   u1_fd5    i8  (IQ, dat_i, clock_i, RN, SN, NOTIFY_REG);
   not       i9  (IQN, IQ);
   and       i10 (qin_and_set, IQN, SN);
   buf       i11 (Q, IQ);
   buf       i12 (QN, qin_and_set);

   checkrs   i13 (c_SH_dat_i, RN, SN);
   not       i14 (SE_not, SE);
   and       i15 (c_SH_D, c_SH_dat_i, SE_not);
   and       i16 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFRSHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFRSHDX1 (CN, D, Q, QN, RN, SD, SE, SN);

   input     CN, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_RN, delay_SN,
                   d_clock_i, d_dat_i, IQN, qin_and_set, c_SH_d_dat_i, SE_not,
                   c_SH_D, c_SH_SD;

   not       i1  (d_clock_i, delay_CN);
   u_mx2     i7  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i8  (IQ, d_dat_i, d_clock_i, delay_RN, delay_SN, NOTIFY_REG);
   not       i9  (IQN, IQ);
   and       i10 (qin_and_set, IQN, delay_SN);
   buf       i11 (Q, IQ);
   buf       i12 (QN, qin_and_set);

   checkrs   i13 (c_SH_d_dat_i, delay_RN, delay_SN);
   not       i14 (SE_not, delay_SE);
   and       i15 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i16 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, IQN, qin_and_set, c_SH_dat_i, SE_not, c_SH_D,
                   c_SH_SD;

   not       i1  (clock_i, CN);
   u_mx2     i7  (dat_i, D, SD, SE);
   u1_fd5    i8  (IQ, dat_i, clock_i, RN, SN, NOTIFY_REG);
   not       i9  (IQN, IQ);
   and       i10 (qin_and_set, IQN, SN);
   buf       i11 (Q, IQ);
   buf       i12 (QN, qin_and_set);

   checkrs   i13 (c_SH_dat_i, RN, SN);
   not       i14 (SE_not, SE);
   and       i15 (c_SH_D, c_SH_dat_i, SE_not);
   and       i16 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFRSHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFRSHDX2 (CN, D, Q, QN, RN, SD, SE, SN);

   input     CN, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_RN, delay_SN,
                   d_clock_i, d_dat_i, IQN, qin_and_set, c_SH_d_dat_i, SE_not,
                   c_SH_D, c_SH_SD;

   not       i1  (d_clock_i, delay_CN);
   u_mx2     i7  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i8  (IQ, d_dat_i, d_clock_i, delay_RN, delay_SN, NOTIFY_REG);
   not       i9  (IQN, IQ);
   and       i10 (qin_and_set, IQN, delay_SN);
   buf       i11 (Q, IQ);
   buf       i12 (QN, qin_and_set);

   checkrs   i13 (c_SH_d_dat_i, delay_RN, delay_SN);
   not       i14 (SE_not, delay_SE);
   and       i15 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i16 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, IQN, qin_and_set, c_SH_dat_i, SE_not, c_SH_D,
                   c_SH_SD;

   not       i1  (clock_i, CN);
   u_mx2     i7  (dat_i, D, SD, SE);
   u1_fd5    i8  (IQ, dat_i, clock_i, RN, SN, NOTIFY_REG);
   not       i9  (IQN, IQ);
   and       i10 (qin_and_set, IQN, SN);
   buf       i11 (Q, IQ);
   buf       i12 (QN, qin_and_set);

   checkrs   i13 (c_SH_dat_i, RN, SN);
   not       i14 (SE_not, SE);
   and       i15 (c_SH_D, c_SH_dat_i, SE_not);
   and       i16 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFRSHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFRSHDX4 (CN, D, Q, QN, RN, SD, SE, SN);

   input     CN, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_RN, delay_SN,
                   d_clock_i, d_dat_i, IQN, qin_and_set, c_SH_d_dat_i, SE_not,
                   c_SH_D, c_SH_SD;

   not       i1  (d_clock_i, delay_CN);
   u_mx2     i7  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i8  (IQ, d_dat_i, d_clock_i, delay_RN, delay_SN, NOTIFY_REG);
   not       i9  (IQN, IQ);
   and       i10 (qin_and_set, IQN, delay_SN);
   buf       i11 (Q, IQ);
   buf       i12 (QN, qin_and_set);

   checkrs   i13 (c_SH_d_dat_i, delay_RN, delay_SN);
   not       i14 (SE_not, delay_SE);
   and       i15 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i16 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, IQN, qin_and_set, c_SH_dat_i, SE_not, c_SH_D,
                   c_SH_SD;

   not       i1  (clock_i, CN);
   u_mx2     i7  (dat_i, D, SD, SE);
   u1_fd5    i8  (IQ, dat_i, clock_i, RN, SN, NOTIFY_REG);
   not       i9  (IQN, IQ);
   and       i10 (qin_and_set, IQN, SN);
   buf       i11 (Q, IQ);
   buf       i12 (QN, qin_and_set);

   checkrs   i13 (c_SH_dat_i, RN, SN);
   not       i14 (SE_not, SE);
   and       i15 (c_SH_D, c_SH_dat_i, SE_not);
   and       i16 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFRSQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Reset, Set and
//                      Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFRSQHDX0 (CN, D, Q, RN, SD, SE, SN);

   input     CN, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_RN, delay_SN,
                   d_clock_i, d_dat_i, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (d_clock_i, delay_CN);
   u_mx2     i7  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i8  (IQ, d_dat_i, d_clock_i, delay_RN, delay_SN, NOTIFY_REG);
   buf       i9  (Q, IQ);

   checkrs   i10 (c_SH_d_dat_i, delay_RN, delay_SN);
   not       i11 (SE_not, delay_SE);
   and       i12 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (clock_i, CN);
   u_mx2     i7  (dat_i, D, SD, SE);
   u1_fd5    i8  (IQ, dat_i, clock_i, RN, SN, NOTIFY_REG);
   buf       i9  (Q, IQ);

   checkrs   i10 (c_SH_dat_i, RN, SN);
   not       i11 (SE_not, SE);
   and       i12 (c_SH_D, c_SH_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFRSQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Reset, Set and
//                      Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFRSQHDX1 (CN, D, Q, RN, SD, SE, SN);

   input     CN, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_RN, delay_SN,
                   d_clock_i, d_dat_i, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (d_clock_i, delay_CN);
   u_mx2     i7  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i8  (IQ, d_dat_i, d_clock_i, delay_RN, delay_SN, NOTIFY_REG);
   buf       i9  (Q, IQ);

   checkrs   i10 (c_SH_d_dat_i, delay_RN, delay_SN);
   not       i11 (SE_not, delay_SE);
   and       i12 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (clock_i, CN);
   u_mx2     i7  (dat_i, D, SD, SE);
   u1_fd5    i8  (IQ, dat_i, clock_i, RN, SN, NOTIFY_REG);
   buf       i9  (Q, IQ);

   checkrs   i10 (c_SH_dat_i, RN, SN);
   not       i11 (SE_not, SE);
   and       i12 (c_SH_D, c_SH_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFRSQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Reset, Set and
//                      Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFRSQHDX2 (CN, D, Q, RN, SD, SE, SN);

   input     CN, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_RN, delay_SN,
                   d_clock_i, d_dat_i, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (d_clock_i, delay_CN);
   u_mx2     i7  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i8  (IQ, d_dat_i, d_clock_i, delay_RN, delay_SN, NOTIFY_REG);
   buf       i9  (Q, IQ);

   checkrs   i10 (c_SH_d_dat_i, delay_RN, delay_SN);
   not       i11 (SE_not, delay_SE);
   and       i12 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (clock_i, CN);
   u_mx2     i7  (dat_i, D, SD, SE);
   u1_fd5    i8  (IQ, dat_i, clock_i, RN, SN, NOTIFY_REG);
   buf       i9  (Q, IQ);

   checkrs   i10 (c_SH_dat_i, RN, SN);
   not       i11 (SE_not, SE);
   and       i12 (c_SH_D, c_SH_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFRSQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Reset, Set and
//                      Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFRSQHDX4 (CN, D, Q, RN, SD, SE, SN);

   input     CN, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_RN, delay_SN,
                   d_clock_i, d_dat_i, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (d_clock_i, delay_CN);
   u_mx2     i7  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i8  (IQ, d_dat_i, d_clock_i, delay_RN, delay_SN, NOTIFY_REG);
   buf       i9  (Q, IQ);

   checkrs   i10 (c_SH_d_dat_i, delay_RN, delay_SN);
   not       i11 (SE_not, delay_SE);
   and       i12 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_CN);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i1  (clock_i, CN);
   u_mx2     i7  (dat_i, D, SD, SE);
   u1_fd5    i8  (IQ, dat_i, clock_i, RN, SN, NOTIFY_REG);
   buf       i9  (Q, IQ);

   checkrs   i10 (c_SH_dat_i, RN, SN);
   not       i11 (SE_not, SE);
   and       i12 (c_SH_D, c_SH_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFSHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFSHDX0 (CN, D, Q, QN, SD, SE, SN);

   input     CN, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_SN, d_clock_i,
                   d_dat_i, IQN, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i0  (d_clock_i, delay_CN);
   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, d_clock_i, 1'b1, delay_SN, NOTIFY_REG);
   not       i8  (IQN, IQ);
   buf       i9  (Q, IQ);
   buf       i10 (QN, IQN);

   checkrs   i11 (c_SH_d_dat_i, 1'b1, delay_SN);
   not       i12 (SE_not, delay_SE);
   and       i13 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i14 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i0  (clock_i, CN);
   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, clock_i, 1'b1, SN, NOTIFY_REG);
   not       i8  (IQN, IQ);
   buf       i9  (Q, IQ);
   buf       i10 (QN, IQN);

   checkrs   i11 (c_SH_dat_i, 1'b1, SN);
   not       i12 (SE_not, SE);
   and       i13 (c_SH_D, c_SH_dat_i, SE_not);
   and       i14 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFSHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFSHDX1 (CN, D, Q, QN, SD, SE, SN);

   input     CN, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_SN, d_clock_i,
                   d_dat_i, IQN, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i0  (d_clock_i, delay_CN);
   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, d_clock_i, 1'b1, delay_SN, NOTIFY_REG);
   not       i8  (IQN, IQ);
   buf       i9  (Q, IQ);
   buf       i10 (QN, IQN);

   checkrs   i11 (c_SH_d_dat_i, 1'b1, delay_SN);
   not       i12 (SE_not, delay_SE);
   and       i13 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i14 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i0  (clock_i, CN);
   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, clock_i, 1'b1, SN, NOTIFY_REG);
   not       i8  (IQN, IQ);
   buf       i9  (Q, IQ);
   buf       i10 (QN, IQN);

   checkrs   i11 (c_SH_dat_i, 1'b1, SN);
   not       i12 (SE_not, SE);
   and       i13 (c_SH_D, c_SH_dat_i, SE_not);
   and       i14 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFSHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFSHDX2 (CN, D, Q, QN, SD, SE, SN);

   input     CN, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_SN, d_clock_i,
                   d_dat_i, IQN, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i0  (d_clock_i, delay_CN);
   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, d_clock_i, 1'b1, delay_SN, NOTIFY_REG);
   not       i8  (IQN, IQ);
   buf       i9  (Q, IQ);
   buf       i10 (QN, IQN);

   checkrs   i11 (c_SH_d_dat_i, 1'b1, delay_SN);
   not       i12 (SE_not, delay_SE);
   and       i13 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i14 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i0  (clock_i, CN);
   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, clock_i, 1'b1, SN, NOTIFY_REG);
   not       i8  (IQN, IQ);
   buf       i9  (Q, IQ);
   buf       i10 (QN, IQN);

   checkrs   i11 (c_SH_dat_i, 1'b1, SN);
   not       i12 (SE_not, SE);
   and       i13 (c_SH_D, c_SH_dat_i, SE_not);
   and       i14 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFSHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge D-Flip-Flop with Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFSHDX4 (CN, D, Q, QN, SD, SE, SN);

   input     CN, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_SN, d_clock_i,
                   d_dat_i, IQN, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i0  (d_clock_i, delay_CN);
   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, d_clock_i, 1'b1, delay_SN, NOTIFY_REG);
   not       i8  (IQN, IQ);
   buf       i9  (Q, IQ);
   buf       i10 (QN, IQN);

   checkrs   i11 (c_SH_d_dat_i, 1'b1, delay_SN);
   not       i12 (SE_not, delay_SE);
   and       i13 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i14 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i0  (clock_i, CN);
   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, clock_i, 1'b1, SN, NOTIFY_REG);
   not       i8  (IQN, IQ);
   buf       i9  (Q, IQ);
   buf       i10 (QN, IQN);

   checkrs   i11 (c_SH_dat_i, 1'b1, SN);
   not       i12 (SE_not, SE);
   and       i13 (c_SH_D, c_SH_dat_i, SE_not);
   and       i14 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFSQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFSQHDX0 (CN, D, Q, SD, SE, SN);

   input     CN, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_SN, d_clock_i,
                   d_dat_i, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i0  (d_clock_i, delay_CN);
   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, d_clock_i, 1'b1, delay_SN, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_d_dat_i, 1'b1, delay_SN);
   not       i10 (SE_not, delay_SE);
   and       i11 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i0  (clock_i, CN);
   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, clock_i, 1'b1, SN, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_dat_i, 1'b1, SN);
   not       i10 (SE_not, SE);
   and       i11 (c_SH_D, c_SH_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFSQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFSQHDX1 (CN, D, Q, SD, SE, SN);

   input     CN, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_SN, d_clock_i,
                   d_dat_i, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i0  (d_clock_i, delay_CN);
   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, d_clock_i, 1'b1, delay_SN, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_d_dat_i, 1'b1, delay_SN);
   not       i10 (SE_not, delay_SE);
   and       i11 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i0  (clock_i, CN);
   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, clock_i, 1'b1, SN, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_dat_i, 1'b1, SN);
   not       i10 (SE_not, SE);
   and       i11 (c_SH_D, c_SH_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFSQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFSQHDX2 (CN, D, Q, SD, SE, SN);

   input     CN, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_SN, d_clock_i,
                   d_dat_i, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i0  (d_clock_i, delay_CN);
   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, d_clock_i, 1'b1, delay_SN, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_d_dat_i, 1'b1, delay_SN);
   not       i10 (SE_not, delay_SE);
   and       i11 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i0  (clock_i, CN);
   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, clock_i, 1'b1, SN, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_dat_i, 1'b1, SN);
   not       i10 (SE_not, SE);
   and       i11 (c_SH_D, c_SH_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFFSQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : negedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFFSQHDX4 (CN, D, Q, SD, SE, SN);

   input     CN, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_CN, delay_D, delay_SD, delay_SE, delay_SN, d_clock_i,
                   d_dat_i, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i0  (d_clock_i, delay_CN);
   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, d_clock_i, 1'b1, delay_SN, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_d_dat_i, 1'b1, delay_SN);
   not       i10 (SE_not, delay_SE);
   and       i11 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_CN, delay_D);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02,
                   NOTIFY_REG,,, delay_CN, delay_SD);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN,
                   delay_SE);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_CN);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, clock_i, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   not       i0  (clock_i, CN);
   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, clock_i, 1'b1, SN, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_dat_i, 1'b1, SN);
   not       i10 (SE_not, SE);
   and       i11 (c_SH_D, c_SH_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

      $setuphold (negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);

      $width (posedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge CN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRHDX0 (C, D, Q, QN, SD, SE);

   input     C, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, d_dat_i, IQN, c_SH_D,
                   c_SH_SD;

   u_mx2     i4  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i5  (IQ, d_dat_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
   not       i6  (IQN, IQ);
   buf       i7  (Q, IQ);
   buf       i8  (QN, IQN);

   not       i9  (c_SH_D, delay_SE);
   buf       i10 (c_SH_SD, delay_SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, IQN, c_SH_D, c_SH_SD;

   u_mx2     i4  (dat_i, D, SD, SE);
   u1_fd5    i5  (IQ, dat_i, C, 1'b1, 1'b1, NOTIFY_REG);
   not       i6  (IQN, IQ);
   buf       i7  (Q, IQ);
   buf       i8  (QN, IQN);

   not       i9  (c_SH_D, SE);
   buf       i10 (c_SH_SD, SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRHDX1 (C, D, Q, QN, SD, SE);

   input     C, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, d_dat_i, IQN, c_SH_D,
                   c_SH_SD;

   u_mx2     i4  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i5  (IQ, d_dat_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
   not       i6  (IQN, IQ);
   buf       i7  (Q, IQ);
   buf       i8  (QN, IQN);

   not       i9  (c_SH_D, delay_SE);
   buf       i10 (c_SH_SD, delay_SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, IQN, c_SH_D, c_SH_SD;

   u_mx2     i4  (dat_i, D, SD, SE);
   u1_fd5    i5  (IQ, dat_i, C, 1'b1, 1'b1, NOTIFY_REG);
   not       i6  (IQN, IQ);
   buf       i7  (Q, IQ);
   buf       i8  (QN, IQN);

   not       i9  (c_SH_D, SE);
   buf       i10 (c_SH_SD, SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRHDX2 (C, D, Q, QN, SD, SE);

   input     C, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, d_dat_i, IQN, c_SH_D,
                   c_SH_SD;

   u_mx2     i4  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i5  (IQ, d_dat_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
   not       i6  (IQN, IQ);
   buf       i7  (Q, IQ);
   buf       i8  (QN, IQN);

   not       i9  (c_SH_D, delay_SE);
   buf       i10 (c_SH_SD, delay_SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, IQN, c_SH_D, c_SH_SD;

   u_mx2     i4  (dat_i, D, SD, SE);
   u1_fd5    i5  (IQ, dat_i, C, 1'b1, 1'b1, NOTIFY_REG);
   not       i6  (IQN, IQ);
   buf       i7  (Q, IQ);
   buf       i8  (QN, IQN);

   not       i9  (c_SH_D, SE);
   buf       i10 (c_SH_SD, SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRHDX4 (C, D, Q, QN, SD, SE);

   input     C, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, d_dat_i, IQN, c_SH_D,
                   c_SH_SD;

   u_mx2     i4  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i5  (IQ, d_dat_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
   not       i6  (IQN, IQ);
   buf       i7  (Q, IQ);
   buf       i8  (QN, IQN);

   not       i9  (c_SH_D, delay_SE);
   buf       i10 (c_SH_SD, delay_SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, IQN, c_SH_D, c_SH_SD;

   u_mx2     i4  (dat_i, D, SD, SE);
   u1_fd5    i5  (IQ, dat_i, C, 1'b1, 1'b1, NOTIFY_REG);
   not       i6  (IQN, IQ);
   buf       i7  (Q, IQ);
   buf       i8  (QN, IQN);

   not       i9  (c_SH_D, SE);
   buf       i10 (c_SH_SD, SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRQHDX0 (C, D, Q, SD, SE);

   input     C, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, d_dat_i, c_SH_D,
                   c_SH_SD;

   u_mx2     i4  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i5  (IQ, d_dat_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
   buf       i6  (Q, IQ);

   not       i7  (c_SH_D, delay_SE);
   buf       i8  (c_SH_SD, delay_SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, c_SH_D, c_SH_SD;

   u_mx2     i4  (dat_i, D, SD, SE);
   u1_fd5    i5  (IQ, dat_i, C, 1'b1, 1'b1, NOTIFY_REG);
   buf       i6  (Q, IQ);

   not       i7  (c_SH_D, SE);
   buf       i8  (c_SH_SD, SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRQHDX1 (C, D, Q, SD, SE);

   input     C, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, d_dat_i, c_SH_D,
                   c_SH_SD;

   u_mx2     i4  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i5  (IQ, d_dat_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
   buf       i6  (Q, IQ);

   not       i7  (c_SH_D, delay_SE);
   buf       i8  (c_SH_SD, delay_SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, c_SH_D, c_SH_SD;

   u_mx2     i4  (dat_i, D, SD, SE);
   u1_fd5    i5  (IQ, dat_i, C, 1'b1, 1'b1, NOTIFY_REG);
   buf       i6  (Q, IQ);

   not       i7  (c_SH_D, SE);
   buf       i8  (c_SH_SD, SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRQHDX2 (C, D, Q, SD, SE);

   input     C, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, d_dat_i, c_SH_D,
                   c_SH_SD;

   u_mx2     i4  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i5  (IQ, d_dat_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
   buf       i6  (Q, IQ);

   not       i7  (c_SH_D, delay_SE);
   buf       i8  (c_SH_SD, delay_SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, c_SH_D, c_SH_SD;

   u_mx2     i4  (dat_i, D, SD, SE);
   u1_fd5    i5  (IQ, dat_i, C, 1'b1, 1'b1, NOTIFY_REG);
   buf       i6  (Q, IQ);

   not       i7  (c_SH_D, SE);
   buf       i8  (c_SH_SD, SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRQHDX4 (C, D, Q, SD, SE);

   input     C, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, d_dat_i, c_SH_D,
                   c_SH_SD;

   u_mx2     i4  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i5  (IQ, d_dat_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
   buf       i6  (Q, IQ);

   not       i7  (c_SH_D, delay_SE);
   buf       i8  (c_SH_SD, delay_SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, c_SH_D, c_SH_SD;

   u_mx2     i4  (dat_i, D, SD, SE);
   u1_fd5    i5  (IQ, dat_i, C, 1'b1, 1'b1, NOTIFY_REG);
   buf       i6  (Q, IQ);

   not       i7  (c_SH_D, SE);
   buf       i8  (c_SH_SD, SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRRHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRRHDX0 (C, D, Q, QN, RN, SD, SE);

   input     C, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_RN, d_dat_i, IQN,
                   c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   checkrs   i10 (c_SH_d_dat_i, delay_RN, 1'b1);
   not       i11 (SE_not, delay_SE);
   and       i12 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, C, RN, 1'b1, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   checkrs   i10 (c_SH_dat_i, RN, 1'b1);
   not       i11 (SE_not, SE);
   and       i12 (c_SH_D, c_SH_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRRHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRRHDX1 (C, D, Q, QN, RN, SD, SE);

   input     C, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_RN, d_dat_i, IQN,
                   c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   checkrs   i10 (c_SH_d_dat_i, delay_RN, 1'b1);
   not       i11 (SE_not, delay_SE);
   and       i12 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, C, RN, 1'b1, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   checkrs   i10 (c_SH_dat_i, RN, 1'b1);
   not       i11 (SE_not, SE);
   and       i12 (c_SH_D, c_SH_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRRHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRRHDX2 (C, D, Q, QN, RN, SD, SE);

   input     C, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_RN, d_dat_i, IQN,
                   c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   checkrs   i10 (c_SH_d_dat_i, delay_RN, 1'b1);
   not       i11 (SE_not, delay_SE);
   and       i12 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, C, RN, 1'b1, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   checkrs   i10 (c_SH_dat_i, RN, 1'b1);
   not       i11 (SE_not, SE);
   and       i12 (c_SH_D, c_SH_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRRHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRRHDX4 (C, D, Q, QN, RN, SD, SE);

   input     C, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_RN, d_dat_i, IQN,
                   c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   checkrs   i10 (c_SH_d_dat_i, delay_RN, 1'b1);
   not       i11 (SE_not, delay_SE);
   and       i12 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, C, RN, 1'b1, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   checkrs   i10 (c_SH_dat_i, RN, 1'b1);
   not       i11 (SE_not, SE);
   and       i12 (c_SH_D, c_SH_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRRQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRRQHDX0 (C, D, Q, RN, SD, SE);

   input     C, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_RN, d_dat_i,
                   c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
   buf       i7  (Q, IQ);

   checkrs   i8  (c_SH_d_dat_i, delay_RN, 1'b1);
   not       i9  (SE_not, delay_SE);
   and       i10 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i11 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, C, RN, 1'b1, NOTIFY_REG);
   buf       i7  (Q, IQ);

   checkrs   i8  (c_SH_dat_i, RN, 1'b1);
   not       i9  (SE_not, SE);
   and       i10 (c_SH_D, c_SH_dat_i, SE_not);
   and       i11 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRRQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRRQHDX1 (C, D, Q, RN, SD, SE);

   input     C, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_RN, d_dat_i,
                   c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
   buf       i7  (Q, IQ);

   checkrs   i8  (c_SH_d_dat_i, delay_RN, 1'b1);
   not       i9  (SE_not, delay_SE);
   and       i10 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i11 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, C, RN, 1'b1, NOTIFY_REG);
   buf       i7  (Q, IQ);

   checkrs   i8  (c_SH_dat_i, RN, 1'b1);
   not       i9  (SE_not, SE);
   and       i10 (c_SH_D, c_SH_dat_i, SE_not);
   and       i11 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRRQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRRQHDX2 (C, D, Q, RN, SD, SE);

   input     C, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_RN, d_dat_i,
                   c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
   buf       i7  (Q, IQ);

   checkrs   i8  (c_SH_d_dat_i, delay_RN, 1'b1);
   not       i9  (SE_not, delay_SE);
   and       i10 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i11 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, C, RN, 1'b1, NOTIFY_REG);
   buf       i7  (Q, IQ);

   checkrs   i8  (c_SH_dat_i, RN, 1'b1);
   not       i9  (SE_not, SE);
   and       i10 (c_SH_D, c_SH_dat_i, SE_not);
   and       i11 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRRQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRRQHDX4 (C, D, Q, RN, SD, SE);

   input     C, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_RN, d_dat_i,
                   c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
   buf       i7  (Q, IQ);

   checkrs   i8  (c_SH_d_dat_i, delay_RN, 1'b1);
   not       i9  (SE_not, delay_SE);
   and       i10 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i11 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, C, RN, 1'b1, NOTIFY_REG);
   buf       i7  (Q, IQ);

   checkrs   i8  (c_SH_dat_i, RN, 1'b1);
   not       i9  (SE_not, SE);
   and       i10 (c_SH_D, c_SH_dat_i, SE_not);
   and       i11 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRRSHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRRSHDX0 (C, D, Q, QN, RN, SD, SE, SN);

   input     C, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_RN, delay_SN,
                   d_dat_i, IQN, qin_and_set, c_SH_d_dat_i, SE_not, c_SH_D,
                   c_SH_SD;

   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
   not       i8  (IQN, IQ);
   and       i9  (qin_and_set, IQN, delay_SN);
   buf       i10 (Q, IQ);
   buf       i11 (QN, qin_and_set);

   checkrs   i12 (c_SH_d_dat_i, delay_RN, delay_SN);
   not       i13 (SE_not, delay_SE);
   and       i14 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i15 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, IQN, qin_and_set, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, C, RN, SN, NOTIFY_REG);
   not       i8  (IQN, IQ);
   and       i9  (qin_and_set, IQN, SN);
   buf       i10 (Q, IQ);
   buf       i11 (QN, qin_and_set);

   checkrs   i12 (c_SH_dat_i, RN, SN);
   not       i13 (SE_not, SE);
   and       i14 (c_SH_D, c_SH_dat_i, SE_not);
   and       i15 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRRSHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRRSHDX1 (C, D, Q, QN, RN, SD, SE, SN);

   input     C, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_RN, delay_SN,
                   d_dat_i, IQN, qin_and_set, c_SH_d_dat_i, SE_not, c_SH_D,
                   c_SH_SD;

   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
   not       i8  (IQN, IQ);
   and       i9  (qin_and_set, IQN, delay_SN);
   buf       i10 (Q, IQ);
   buf       i11 (QN, qin_and_set);

   checkrs   i12 (c_SH_d_dat_i, delay_RN, delay_SN);
   not       i13 (SE_not, delay_SE);
   and       i14 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i15 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, IQN, qin_and_set, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, C, RN, SN, NOTIFY_REG);
   not       i8  (IQN, IQ);
   and       i9  (qin_and_set, IQN, SN);
   buf       i10 (Q, IQ);
   buf       i11 (QN, qin_and_set);

   checkrs   i12 (c_SH_dat_i, RN, SN);
   not       i13 (SE_not, SE);
   and       i14 (c_SH_D, c_SH_dat_i, SE_not);
   and       i15 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRRSHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRRSHDX2 (C, D, Q, QN, RN, SD, SE, SN);

   input     C, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_RN, delay_SN,
                   d_dat_i, IQN, qin_and_set, c_SH_d_dat_i, SE_not, c_SH_D,
                   c_SH_SD;

   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
   not       i8  (IQN, IQ);
   and       i9  (qin_and_set, IQN, delay_SN);
   buf       i10 (Q, IQ);
   buf       i11 (QN, qin_and_set);

   checkrs   i12 (c_SH_d_dat_i, delay_RN, delay_SN);
   not       i13 (SE_not, delay_SE);
   and       i14 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i15 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, IQN, qin_and_set, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, C, RN, SN, NOTIFY_REG);
   not       i8  (IQN, IQ);
   and       i9  (qin_and_set, IQN, SN);
   buf       i10 (Q, IQ);
   buf       i11 (QN, qin_and_set);

   checkrs   i12 (c_SH_dat_i, RN, SN);
   not       i13 (SE_not, SE);
   and       i14 (c_SH_D, c_SH_dat_i, SE_not);
   and       i15 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRRSHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRRSHDX4 (C, D, Q, QN, RN, SD, SE, SN);

   input     C, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_RN, delay_SN,
                   d_dat_i, IQN, qin_and_set, c_SH_d_dat_i, SE_not, c_SH_D,
                   c_SH_SD;

   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
   not       i8  (IQN, IQ);
   and       i9  (qin_and_set, IQN, delay_SN);
   buf       i10 (Q, IQ);
   buf       i11 (QN, qin_and_set);

   checkrs   i12 (c_SH_d_dat_i, delay_RN, delay_SN);
   not       i13 (SE_not, delay_SE);
   and       i14 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i15 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, IQN, qin_and_set, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, C, RN, SN, NOTIFY_REG);
   not       i8  (IQN, IQ);
   and       i9  (qin_and_set, IQN, SN);
   buf       i10 (Q, IQ);
   buf       i11 (QN, qin_and_set);

   checkrs   i12 (c_SH_dat_i, RN, SN);
   not       i13 (SE_not, SE);
   and       i14 (c_SH_D, c_SH_dat_i, SE_not);
   and       i15 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (SN +=> QN) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRRSQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Reset, Set and
//                      Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRRSQHDX0 (C, D, Q, RN, SD, SE, SN);

   input     C, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_RN, delay_SN,
                   d_dat_i, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_d_dat_i, delay_RN, delay_SN);
   not       i10 (SE_not, delay_SE);
   and       i11 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, C, RN, SN, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_dat_i, RN, SN);
   not       i10 (SE_not, SE);
   and       i11 (c_SH_D, c_SH_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRRSQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Reset, Set and
//                      Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRRSQHDX1 (C, D, Q, RN, SD, SE, SN);

   input     C, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_RN, delay_SN,
                   d_dat_i, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_d_dat_i, delay_RN, delay_SN);
   not       i10 (SE_not, delay_SE);
   and       i11 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, C, RN, SN, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_dat_i, RN, SN);
   not       i10 (SE_not, SE);
   and       i11 (c_SH_D, c_SH_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRRSQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Reset, Set and
//                      Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRRSQHDX2 (C, D, Q, RN, SD, SE, SN);

   input     C, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_RN, delay_SN,
                   d_dat_i, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_d_dat_i, delay_RN, delay_SN);
   not       i10 (SE_not, delay_SE);
   and       i11 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, C, RN, SN, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_dat_i, RN, SN);
   not       i10 (SE_not, SE);
   and       i11 (c_SH_D, c_SH_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRRSQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Reset, Set and
//                      Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRRSQHDX4 (C, D, Q, RN, SD, SE, SN);

   input     C, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_RN, delay_SN,
                   d_dat_i, c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i6  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i7  (IQ, d_dat_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_d_dat_i, delay_RN, delay_SN);
   not       i10 (SE_not, delay_SE);
   and       i11 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_SN);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN,
                   delay_C);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i6  (dat_i, D, SD, SE);
   u1_fd5    i7  (IQ, dat_i, C, RN, SN, NOTIFY_REG);
   buf       i8  (Q, IQ);

   checkrs   i9  (c_SH_dat_i, RN, SN);
   not       i10 (SE_not, SE);
   and       i11 (c_SH_D, c_SH_dat_i, SE_not);
   and       i12 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge RN, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRSHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRSHDX0 (C, D, Q, QN, SD, SE, SN);

   input     C, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_SN, d_dat_i, IQN,
                   c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   checkrs   i10 (c_SH_d_dat_i, 1'b1, delay_SN);
   not       i11 (SE_not, delay_SE);
   and       i12 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, C, 1'b1, SN, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   checkrs   i10 (c_SH_dat_i, 1'b1, SN);
   not       i11 (SE_not, SE);
   and       i12 (c_SH_D, c_SH_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRSHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRSHDX1 (C, D, Q, QN, SD, SE, SN);

   input     C, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_SN, d_dat_i, IQN,
                   c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   checkrs   i10 (c_SH_d_dat_i, 1'b1, delay_SN);
   not       i11 (SE_not, delay_SE);
   and       i12 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, C, 1'b1, SN, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   checkrs   i10 (c_SH_dat_i, 1'b1, SN);
   not       i11 (SE_not, SE);
   and       i12 (c_SH_D, c_SH_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRSHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRSHDX2 (C, D, Q, QN, SD, SE, SN);

   input     C, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_SN, d_dat_i, IQN,
                   c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   checkrs   i10 (c_SH_d_dat_i, 1'b1, delay_SN);
   not       i11 (SE_not, delay_SE);
   and       i12 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, C, 1'b1, SN, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   checkrs   i10 (c_SH_dat_i, 1'b1, SN);
   not       i11 (SE_not, SE);
   and       i12 (c_SH_D, c_SH_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRSHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge D-Flip-Flop with Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRSHDX4 (C, D, Q, QN, SD, SE, SN);

   input     C, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_SN, d_dat_i, IQN,
                   c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   checkrs   i10 (c_SH_d_dat_i, 1'b1, delay_SN);
   not       i11 (SE_not, delay_SE);
   and       i12 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, C, 1'b1, SN, NOTIFY_REG);
   not       i7  (IQN, IQ);
   buf       i8  (Q, IQ);
   buf       i9  (QN, IQN);

   checkrs   i10 (c_SH_dat_i, 1'b1, SN);
   not       i11 (SE_not, SE);
   and       i12 (c_SH_D, c_SH_dat_i, SE_not);
   and       i13 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      (negedge SN => (QN +: SN)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRSQHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRSQHDX0 (C, D, Q, SD, SE, SN);

   input     C, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_SN, d_dat_i,
                   c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
   buf       i7  (Q, IQ);

   checkrs   i8  (c_SH_d_dat_i, 1'b1, delay_SN);
   not       i9  (SE_not, delay_SE);
   and       i10 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i11 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, C, 1'b1, SN, NOTIFY_REG);
   buf       i7  (Q, IQ);

   checkrs   i8  (c_SH_dat_i, 1'b1, SN);
   not       i9  (SE_not, SE);
   and       i10 (c_SH_D, c_SH_dat_i, SE_not);
   and       i11 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRSQHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRSQHDX1 (C, D, Q, SD, SE, SN);

   input     C, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_SN, d_dat_i,
                   c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
   buf       i7  (Q, IQ);

   checkrs   i8  (c_SH_d_dat_i, 1'b1, delay_SN);
   not       i9  (SE_not, delay_SE);
   and       i10 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i11 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, C, 1'b1, SN, NOTIFY_REG);
   buf       i7  (Q, IQ);

   checkrs   i8  (c_SH_dat_i, 1'b1, SN);
   not       i9  (SE_not, SE);
   and       i10 (c_SH_D, c_SH_dat_i, SE_not);
   and       i11 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRSQHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRSQHDX2 (C, D, Q, SD, SE, SN);

   input     C, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_SN, d_dat_i,
                   c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
   buf       i7  (Q, IQ);

   checkrs   i8  (c_SH_d_dat_i, 1'b1, delay_SN);
   not       i9  (SE_not, delay_SE);
   and       i10 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i11 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, C, 1'b1, SN, NOTIFY_REG);
   buf       i7  (Q, IQ);

   checkrs   i8  (c_SH_dat_i, 1'b1, SN);
   not       i9  (SE_not, SE);
   and       i10 (c_SH_D, c_SH_dat_i, SE_not);
   and       i11 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SDFRSQHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : posedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLICDD generated
//****************************************************************************

module SDFRSQHDX4 (C, D, Q, SD, SE, SN);

   input     C, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, delay_C, delay_D, delay_SD, delay_SE, delay_SN, d_dat_i,
                   c_SH_d_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (d_dat_i, delay_D, delay_SD, delay_SE);
   u1_fd5    i6  (IQ, d_dat_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
   buf       i7  (Q, IQ);

   checkrs   i8  (c_SH_d_dat_i, 1'b1, delay_SN);
   not       i9  (SE_not, delay_SE);
   and       i10 (c_SH_D, c_SH_d_dat_i, SE_not);
   and       i11 (c_SH_SD, c_SH_d_dat_i, delay_SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_D);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,,
                   delay_C, delay_SD);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C,
                   delay_SE);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN,
                   delay_C);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`else   // NEG_TCHK

   reg       NOTIFY_REG;
   wire	     IQ, dat_i, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

   u_mx2     i5  (dat_i, D, SD, SE);
   u1_fd5    i6  (IQ, dat_i, C, 1'b1, SN, NOTIFY_REG);
   buf       i7  (Q, IQ);

   checkrs   i8  (c_SH_dat_i, 1'b1, SN);
   not       i9  (SE_not, SE);
   and       i10 (c_SH_D, c_SH_dat_i, SE_not);
   and       i11 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify

      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);

      $setuphold (posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);

      $setuphold (posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
      $setuphold (posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);

      $recrem (posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);

      $width (posedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge C, 0.02, 0, NOTIFY_REG);
      $width (negedge SN, 0.02, 0, NOTIFY_REG);

   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : STEHDX0
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : ESD/EMC optimized buffer with CMOS Schmitt Trigger
//                      input
//   last modified by : XLICDD generated
//****************************************************************************

module STEHDX0 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : STEHDX1
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : ESD/EMC optimized buffer with CMOS Schmitt Trigger
//                      input
//   last modified by : XLICDD generated
//****************************************************************************

module STEHDX1 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : STEHDX2
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : ESD/EMC optimized buffer with CMOS Schmitt Trigger
//                      input
//   last modified by : XLICDD generated
//****************************************************************************

module STEHDX2 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : STEHDX4
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : ESD/EMC optimized buffer with CMOS Schmitt Trigger
//                      input
//   last modified by : XLICDD generated
//****************************************************************************

module STEHDX4 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
//*****************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : SIGNALHOLDHD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Leakage current compensator
//   last modified by : XLICDD generated
//*****************************************************************

module SIGNALHOLDHD (SIG);

   inout SIG;

// logic section  
  `ifdef DISPLAY_HOLD 
  
        buf i1 (n1, SIG);
        buf (pull1, pull0) i2 (SIG, n1);

     initial
     begin
      #0 $display("  > Warning: compiler directive DISPLAY_HOLD is set in cell"
                               );
         $display("  > %m");
         $display("  > SIGNALHOLD cell model is switched to provide logic levels"
                  );
         $display("  >  - danger of reading not really driven values ");   
                   
         $display("  >  - undriven bus states are not detectable now ");   
                   
         $display("  >");    
     end

  `else
// - no logic behaviour modelled for the electrical function of 
//   signalhold cell 
// - signalhold cell compensates leackage current only in case of
//   undriven node/bus and system stop
// - signalhold cell holds the bus bit on "0" or "1", but does not 
//   drive it, this is not in every case the same as the last valid 
//   logic value considering the desired application meaning
// - undriven bus bit should not be used as sequential element
// - reading from undriven bus_bit ("Z") has to provide ("X") in the
//   related block to detect such cases in simulation
//
// Use the compiler directive command
//   `define  DISPLAY_HOLD yes
// to enable the logic pullup/down behaviour of the Leakage current 
// compensator cell SIGNALHOLD*
//
     buf i3 (n1, SIG);
     bufif1 i4 (SIG, n1, 1'b0); /* always inactive */
  `endif
 
// no timing modelled for signalhold cell
// no backannotation possible for signalhold cell 
    

// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LOGIC0HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Constant logic 0
//   last modified by : XLICDD generated
//****************************************************************************

module LOGIC0HD (Q);

   output    Q;

// Function Q: 0
   buf       i0   (Q, 1'b0);

// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : LOGIC1HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Constant logic 1
//   last modified by : XLICDD generated
//****************************************************************************

module LOGIC1HD (Q);

   output    Q;

// Function Q: 1
   buf       i0   (Q, 1'b1);

// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : MPROBEBUHDX8
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Microprobe cell for buffered signal output (signal
//                      decoupling)
//   last modified by : XLICDD generated
//****************************************************************************

module MPROBEBUHDX8 (A);

   input     A;

// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : MPROBEHD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Micro probe cell for direct wire access
//   last modified by : XLICDD generated
//****************************************************************************

module MPROBEHD (A);

   input     A;

// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FEED1HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell
//   last modified by : XLICDD generated
//****************************************************************************

module FEED1HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FEED2HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell
//   last modified by : XLICDD generated
//****************************************************************************

module FEED2HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FEED3HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell
//   last modified by : XLICDD generated
//****************************************************************************

module FEED3HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FEED5HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell
//   last modified by : XLICDD generated
//****************************************************************************

module FEED5HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FEED7HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell
//   last modified by : XLICDD generated
//****************************************************************************

module FEED7HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FEED10HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell
//   last modified by : XLICDD generated
//****************************************************************************

module FEED10HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FEED15HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell
//   last modified by : XLICDD generated
//****************************************************************************

module FEED15HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FEED25HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell
//   last modified by : XLICDD generated
//****************************************************************************

module FEED25HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DECAP3HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, ESD
//                      optimized
//   last modified by : XLICDD generated
//****************************************************************************

module DECAP3HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DECAP5HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, ESD
//                      optimized
//   last modified by : XLICDD generated
//****************************************************************************

module DECAP5HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DECAP7HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, ESD
//                      optimized
//   last modified by : XLICDD generated
//****************************************************************************

module DECAP7HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DECAP10HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, ESD
//                      optimized
//   last modified by : XLICDD generated
//****************************************************************************

module DECAP10HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DECAP15HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, ESD
//                      optimized
//   last modified by : XLICDD generated
//****************************************************************************

module DECAP15HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : DECAP25HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, ESD
//                      optimized
//   last modified by : XLICDD generated
//****************************************************************************

module DECAP25HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE2HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE2HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE3HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE3HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE4HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE4HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE5HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE5HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE6HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE6HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE7HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE7HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE8HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE8HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE9HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE9HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE10HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE10HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE11HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE11HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE12HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE12HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE13HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE13HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE14HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE14HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE15HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE15HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE16HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE16HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE17HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE17HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE18HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE18HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE19HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE19HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE20HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE20HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE21HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE21HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE22HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE22HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE23HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE23HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE24HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE24HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE25HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE25HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE26HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE26HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE27HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE27HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE28HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE28HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE29HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE29HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE30HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE30HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE31HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE31HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNE32HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor
//   last modified by : XLICDD generated
//****************************************************************************

module FCNE32HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED5HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED5HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED6HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED6HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED7HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED7HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED8HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED8HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED9HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED9HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED10HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED10HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED11HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED11HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED12HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED12HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED13HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED13HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED14HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED14HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED15HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED15HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED16HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED16HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED17HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED17HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED18HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED18HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED19HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED19HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED20HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED20HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED21HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED21HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED22HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED22HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED23HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED23HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED24HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED24HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED25HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED25HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED26HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED26HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED27HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED27HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED28HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED28HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED29HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED29HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED30HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED30HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED31HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED31HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : FCNED32HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Filler cell with buffering capacitance, built on NE
//                      transistor, double cell height
//   last modified by : XLICDD generated
//****************************************************************************

module FCNED32HD ();


// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ANTENNACELLN2HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : protection cell against antenna effects (net
//                      charge) at manufacture, NIMP diode in substrate
//   last modified by : XLICDD generated
//****************************************************************************

module ANTENNACELLN2HD (A);

   input     A;

// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ANTENNACELLNP2HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : protection cell against antenna effects (net
//                      charge) at manufacture, PIMP diode in NWELL, NIMP
//                 diode in substrate
//   last modified by : XLICDD generated
//****************************************************************************

module ANTENNACELLNP2HD (A);

   input     A;

// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : ANTENNACELLP2HD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : protection cell against antenna effects (net
//                      charge) at manufacture, PIMP diode in NWELL
//   last modified by : XLICDD generated
//****************************************************************************

module ANTENNACELLP2HD (A);

   input     A;

// timing section:
   specify

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 0.18um HV SOI CMOS
//   module name      : CLKVBUFHD
//   version          : 4.0.0, Tue Dec  5 07:10:53 2017
//   cell_description : Virtual Clock Tree Buffer
//   last modified by : XLICDD generated
//****************************************************************************

module CLKVBUFHD (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify

      (A +=> Q) = (0.02, 0.02);

   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine
